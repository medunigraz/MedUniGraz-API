{"ast":null,"code":"import { USEHTTPSERVICE, ABOVE_LEVEL_OFFSET, BELOW_LEVEL_OFFSET } from '../base/globalconstants';\nimport { MapLayerBase } from './mapLayerBase';\nimport { OpenlayersHelper } from './openlayershelper';\nimport { MapEdgeStyles } from './mapEdgeStyles';\nimport ol_style_Style from 'ol/style/Style';\nimport ol_style_Stroke from 'ol/style/Stroke';\nimport ol_format_GeoJSON from 'ol/format/GeoJSON';\nimport ol_geom_LineString from 'ol/geom/LineString';\nimport ol_layer_Vector from 'ol/layer/Vector';\nimport ol_source_Vector from 'ol/source/Vector';\nexport class MapEdges extends MapLayerBase {\n  constructor(mapService) {\n    super();\n    this.mapService = mapService;\n    this.highlightedFeature = null;\n    this.highlightFeatureOverlay = null;\n    this.selectFeature = null;\n    this.selectFeatureOverlay = null;\n    this.isWeightMode = false;\n    this.currentEdgeWeight = null;\n    this.currentLevel = undefined;\n    this.multiLevelMode = false;\n    this.Initialize();\n  }\n  Initialize() {\n    let styleFunction = function (feature) {\n      let style = MapEdgeStyles.GetStyle(feature.get(\"category\"));\n      return style;\n    };\n    let res = OpenlayersHelper.CreateBasicLayer(feature => styleFunction(feature));\n    this.layerSource = res.layerSource;\n    this.layer = res.layer;\n  }\n  updateData(floor, multiLevel) {\n    this.clear();\n    this.currentLevel = floor;\n    this.multiLevelMode = multiLevel;\n    this.subscribeNewRequest(this.mapService.getNavigationEdges(floor.id).subscribe(edges => this.showEdges(edges), error => console.log(\"ERROR deleteNode: \" + error)));\n  }\n  setWeightMode(weightmode) {\n    console.log(\"MapEdges::setWeightmode -> \" + weightmode);\n    this.isWeightMode = weightmode;\n  }\n  setCurrentEdgeWeight(edgeWeight) {\n    console.log(\"MapEdges::setCurrentEdgeWeight -> \" + JSON.stringify(edgeWeight));\n    this.currentEdgeWeight = edgeWeight;\n  }\n  setEdgeWeights(edgeWeights) {\n    MapEdgeStyles.InitStyles(edgeWeights);\n    this.layerSource.refresh();\n    console.log(\"MapEdges::setEdgeWeights -> \" + JSON.stringify(edgeWeights));\n  }\n  getHighlightedEdgeId() {\n    if (this.highlightedFeature) {\n      return this.highlightedFeature.getId();\n    }\n    return -1;\n  }\n  getEdgeForId(id) {\n    return this.layerSource.getFeatureById(id);\n  }\n  updateMouseMoved(position, map, allowHighlight) {\n    if (this.highlightFeatureOverlay === null) {\n      this.initHighlightFeatureOverlay(map);\n    }\n    let options = {\n      layerFilter: layer => this.testLayer(layer)\n    };\n    let feature = null;\n    if (allowHighlight) {\n      feature = map.forEachFeatureAtPixel(position, function (feature) {\n        return feature;\n      }, options);\n    }\n    if (feature !== this.highlightedFeature) {\n      if (this.highlightedFeature) {\n        this.highlightFeatureOverlay.getSource().removeFeature(this.highlightedFeature);\n      }\n      if (feature) {\n        //console.log('Highlight feature: ' + JSON.stringify(feature.getKeys()));\n        //console.log('Highlight feature: ' + JSON.stringify(feature.get('id')));\n        this.highlightFeatureOverlay.getSource().addFeature(feature);\n      }\n      this.highlightedFeature = feature;\n    }\n  }\n  updateMouseClicked(map) {\n    //console.log(\"mapEdges::updateMouseClicked...\")\n    if (this.highlightedFeature) {\n      if (this.isWeightMode) {\n        let id = this.highlightedFeature.getId();\n        let weight = this.highlightedFeature.get(\"category\");\n        if (this.currentEdgeWeight) {\n          if (this.currentEdgeWeight.id != weight) {\n            console.log(\"mapEdges::updateMouseClicked - Change edge \" + id + \" to weight: \" + this.currentEdgeWeight.id + \"/\" + this.currentEdgeWeight.name);\n            this.highlightedFeature.set(\"category\", this.currentEdgeWeight.id);\n            //TODO SEND UPDATE\n            let clonedFeature = this.highlightedFeature.clone();\n            clonedFeature.setId(this.highlightedFeature.getId());\n            let line = this.getEdgeLine(new ol_format_GeoJSON().readFeature(clonedFeature.get('source_node')), new ol_format_GeoJSON().readFeature(clonedFeature.get('destination_node')));\n            clonedFeature.setGeometry(line);\n            this.mapService.updateEdge(new ol_format_GeoJSON().writeFeature(clonedFeature), this.highlightedFeature.getId()).subscribe(edge => this.edgeUpdated(edge), error => console.log(\"ERROR: \" + error));\n          }\n        }\n      } else {\n        if (!this.selectFeatureOverlay) {\n          this.initSelectFeatureOverlay(map);\n        }\n        this.selectFeatureOverlay.getSource().clear();\n        this.selectFeature = this.highlightedFeature;\n        this.selectFeatureOverlay.getSource().addFeature(this.selectFeature);\n        console.log(\"mapEdges::updateMouseClicked Select Edge: \" + this.selectFeature.getId());\n      }\n    } else {\n      this.clearSelection();\n    }\n  }\n  clearSelection() {\n    if (this.selectFeatureOverlay) {\n      console.log(\"mapEdges::clearSelection...\");\n      this.selectFeatureOverlay.getSource().clear();\n    }\n  }\n  deleteSelectedEdges() {\n    if (!USEHTTPSERVICE) {\n      console.log(\"Offline mode, dont delete edge!\");\n      return;\n    }\n    if (this.selectFeature) this.mapService.deleteEdge(this.selectFeature.getId()).subscribe(edge => this.edgeDeleted(edge), error => console.log(\"ERROR deleteNode: \" + error));\n  }\n  deleteEdgeById(id) {\n    if (!USEHTTPSERVICE) {\n      console.log(\"Offline mode, dont delete edge!\");\n      return;\n    }\n    this.mapService.deleteEdge(id).subscribe(edge => this.edgeDeleted(edge), error => console.log(\"ERROR deleteNode: \" + error));\n  }\n  addNewEdge(start, end) {\n    console.log(\"addNewEdge! - \" + JSON.stringify(start.getId()) + \" to \" + end.getId());\n    if (!start || !end) {\n      return;\n    }\n    let sourceId = start.getId();\n    let destinationId = end.getId();\n    if (sourceId == destinationId) {\n      return;\n    }\n    /*\r\n        let p1 = start.getGeometry().getCoordinates();\r\n        let p2 = end.getGeometry().getCoordinates();\r\n              if (this.multiLevelMode && start.get('level') == this.currentLevel.floorAbove) {\r\n          p1[0] = p1[0] - ABOVE_LEVEL_OFFSET;\r\n        }\r\n        else if (this.multiLevelMode && start.get('level') == this.currentLevel.floorBelow) {\r\n          p1[0] = p1[0] - BELOW_LEVEL_OFFSET;\r\n        }\r\n              if (this.multiLevelMode && end.get('level') == this.currentLevel.floorAbove) {\r\n          p2[0] = p2[0] - ABOVE_LEVEL_OFFSET;\r\n        }\r\n        else if (this.multiLevelMode && end.get('level') == this.currentLevel.floorBelow) {\r\n          p2[0] = p2[0] - BELOW_LEVEL_OFFSET;\r\n        }\r\n              let line = new ol.geom.LineString([p1, p2]);*/\n    let line = this.getEdgeLine(start, end);\n    let distance = line.getLength();\n    let path = {\n      'type': 'LineString',\n      'coordinates': [\n      //p1,\n      //p2\n      line.getFirstCoordinate(), line.getLastCoordinate()]\n    };\n    this.mapService.addEdge(sourceId, destinationId, distance, path).subscribe(edge => this.edgeAdded(edge), error => console.log(\"ERROR: \" + error));\n  }\n  getEdgeLine(startNode, endNode) {\n    let p1 = startNode.getGeometry().getCoordinates();\n    let p2 = endNode.getGeometry().getCoordinates();\n    if (this.multiLevelMode && startNode.get('level') == this.currentLevel.floorAbove) {\n      p1[0] = p1[0] - ABOVE_LEVEL_OFFSET;\n    } else if (this.multiLevelMode && startNode.get('level') == this.currentLevel.floorBelow) {\n      p1[0] = p1[0] - BELOW_LEVEL_OFFSET;\n    }\n    if (this.multiLevelMode && endNode.get('level') == this.currentLevel.floorAbove) {\n      p2[0] = p2[0] - ABOVE_LEVEL_OFFSET;\n    } else if (this.multiLevelMode && endNode.get('level') == this.currentLevel.floorBelow) {\n      p2[0] = p2[0] - BELOW_LEVEL_OFFSET;\n    }\n    return new ol_geom_LineString([p1, p2]);\n  }\n  getEdgesForNode(nodeId) {\n    return this.layerSource.getFeatures().filter(feature => feature.get(\"source\") == nodeId || feature.get(\"destination\") == nodeId);\n  }\n  removeEdgesForNode(nodeId) {\n    console.log(\"MapEdges::removeEdgesForNode - \" + nodeId);\n    let edges = this.getEdgesForNode(nodeId);\n    for (let edge of edges) {\n      this.layerSource.removeFeature(edge);\n    }\n  }\n  edgeDeleted(edge) {\n    let feature = this.layerSource.getFeatureById(edge.id);\n    if (feature) {\n      this.layerSource.removeFeature(feature);\n      this.clearSelection();\n    }\n  }\n  edgeAdded(edge) {\n    let ol_edge = new ol_format_GeoJSON().readFeature(edge);\n    ol_edge = this.getUpdatedMultiLayerEdge(ol_edge);\n    this.layerSource.addFeature(ol_edge);\n  }\n  initHighlightFeatureOverlay(map) {\n    this.highlightFeatureOverlay = new ol_layer_Vector({\n      source: new ol_source_Vector(),\n      map: map,\n      style: new ol_style_Style({\n        stroke: new ol_style_Stroke({\n          color: 'red',\n          width: 4\n        })\n      })\n    });\n  }\n  initSelectFeatureOverlay(map) {\n    console.log(\"mapEdges::initSelectFeatureOverlay...\");\n    this.selectFeatureOverlay = new ol_layer_Vector({\n      source: new ol_source_Vector(),\n      map: map,\n      style: new ol_style_Style({\n        stroke: new ol_style_Stroke({\n          color: 'rgba(0,190,255,0.8)',\n          width: 6\n        })\n      })\n    });\n  }\n  testLayer(layer) {\n    return this.layer === layer;\n  }\n  showEdges(features) {\n    console.log(\"MapEdges::showEdges\");\n    this.clear();\n    //TODO Add LAYER OFFSET\n    let ol_features = new ol_format_GeoJSON().readFeatures(features);\n    for (let i = 0; i < ol_features.length; i++) {\n      ol_features[i] = this.getUpdatedMultiLayerEdge(ol_features[i]);\n    }\n    this.layerSource.addFeatures(ol_features);\n  }\n  edgeUpdated(edge) {\n    //Nothing todo\n    console.log(\"mapEdges::edgeUpdated!!!\");\n  }\n  getUpdatedMultiLayerEdge(edgeFeature) {\n    let coords = edgeFeature.getGeometry().getCoordinates();\n    let sourceLevel = edgeFeature.get(\"source_node\").properties.level;\n    let destinationLevel = edgeFeature.get(\"destination_node\").properties.level;\n    //console.log(\"MapEdges::showEdges oldcoords\" + JSON.stringify(coords));\n    if (sourceLevel == this.currentLevel.floorAbove) {\n      coords[0][0] = coords[0][0] + ABOVE_LEVEL_OFFSET;\n    }\n    if (sourceLevel == this.currentLevel.floorBelow) {\n      coords[0][0] = coords[0][0] + BELOW_LEVEL_OFFSET;\n    }\n    if (destinationLevel == this.currentLevel.floorAbove) {\n      coords[1][0] = coords[1][0] + ABOVE_LEVEL_OFFSET;\n    }\n    if (destinationLevel == this.currentLevel.floorBelow) {\n      coords[1][0] = coords[1][0] + BELOW_LEVEL_OFFSET;\n    }\n    //console.log(\"MapEdges::showEdges newcoords \" + JSON.stringify(coords));\n    edgeFeature.getGeometry().setCoordinates(coords);\n    return edgeFeature;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}