{"ast":null,"code":"import { __decorate, __awaiter, __param, __metadata } from 'tslib';\nimport { Injectable, NgZone, Optional, Inject, NgModule, InjectionToken } from '@angular/core';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { HttpHeaders, HttpParams, HttpClient, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { Subject, of, from, race, combineLatest, throwError, merge } from 'rxjs';\nimport { filter, tap, debounceTime, delay, switchMap, map, first, catchError, timeout, take, mergeMap } from 'rxjs/operators';\nimport { sha256 } from 'js-sha256';\n\n/**\r\n * Additional options that can be passed to tryLogin.\r\n */\nclass LoginOptions {\n  constructor() {\n    /**\r\n     * Normally, you want to clear your hash fragment after\r\n     * the lib read the token(s) so that they are not displayed\r\n     * anymore in the url. If not, set this to true. For code flow\r\n     * this controls removing query string values.\r\n     */\n    this.preventClearHashAfterLogin = false;\n  }\n}\n/**\r\n * Defines the logging interface the OAuthService uses\r\n * internally. Is compatible with the `console` object,\r\n * but you can provide your own implementation as well\r\n * through dependency injection.\r\n */\nclass OAuthLogger {}\n/**\r\n * Defines a simple storage that can be used for\r\n * storing the tokens at client side.\r\n * Is compatible to localStorage and sessionStorage,\r\n * but you can also create your own implementations.\r\n */\nclass OAuthStorage {}\nlet MemoryStorage = /*#__PURE__*/(() => {\n  let MemoryStorage = class MemoryStorage {\n    constructor() {\n      this.data = new Map();\n    }\n    getItem(key) {\n      return this.data.get(key);\n    }\n    removeItem(key) {\n      this.data.delete(key);\n    }\n    setItem(key, data) {\n      this.data.set(key, data);\n    }\n  };\n  MemoryStorage = __decorate([Injectable()], MemoryStorage);\n  /**\r\n   * Represents the received tokens, the received state\r\n   * and the parsed claims from the id-token.\r\n   */\n  return MemoryStorage;\n})();\nclass ReceivedTokens {}\n\n// see: https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_.22Unicode_Problem.22\nfunction b64DecodeUnicode(str) {\n  const base64 = str.replace(/\\-/g, '+').replace(/\\_/g, '/');\n  return decodeURIComponent(atob(base64).split('').map(function (c) {\n    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n  }).join(''));\n}\nfunction base64UrlEncode(str) {\n  const base64 = btoa(str);\n  return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\n/**\r\n * Interface for Handlers that are hooked in to\r\n * validate tokens.\r\n */\nclass ValidationHandler {}\n/**\r\n * This abstract implementation of ValidationHandler already implements\r\n * the method validateAtHash. However, to make use of it,\r\n * you have to override the method calcHash.\r\n */\nclass AbstractValidationHandler {\n  /**\r\n   * Validates the at_hash in an id_token against the received access_token.\r\n   */\n  validateAtHash(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let hashAlg = this.inferHashAlgorithm(params.idTokenHeader);\n      let tokenHash = yield this.calcHash(params.accessToken, hashAlg); // sha256(accessToken, { asString: true });\n      let leftMostHalf = tokenHash.substr(0, tokenHash.length / 2);\n      let atHash = base64UrlEncode(leftMostHalf);\n      let claimsAtHash = params.idTokenClaims['at_hash'].replace(/=/g, '');\n      if (atHash !== claimsAtHash) {\n        console.error('exptected at_hash: ' + atHash);\n        console.error('actual at_hash: ' + claimsAtHash);\n      }\n      return atHash === claimsAtHash;\n    });\n  }\n  /**\r\n   * Infers the name of the hash algorithm to use\r\n   * from the alg field of an id_token.\r\n   *\r\n   * @param jwtHeader the id_token's parsed header\r\n   */\n  inferHashAlgorithm(jwtHeader) {\n    let alg = jwtHeader['alg'];\n    if (!alg.match(/^.S[0-9]{3}$/)) {\n      throw new Error('Algorithm not supported: ' + alg);\n    }\n    return 'sha-' + alg.substr(2);\n  }\n}\nlet UrlHelperService = /*#__PURE__*/(() => {\n  let UrlHelperService = class UrlHelperService {\n    getHashFragmentParams(customHashFragment) {\n      let hash = customHashFragment || window.location.hash;\n      hash = decodeURIComponent(hash);\n      if (hash.indexOf('#') !== 0) {\n        return {};\n      }\n      const questionMarkPosition = hash.indexOf('?');\n      if (questionMarkPosition > -1) {\n        hash = hash.substr(questionMarkPosition + 1);\n      } else {\n        hash = hash.substr(1);\n      }\n      return this.parseQueryString(hash);\n    }\n    parseQueryString(queryString) {\n      const data = {};\n      let pairs, pair, separatorIndex, escapedKey, escapedValue, key, value;\n      if (queryString === null) {\n        return data;\n      }\n      pairs = queryString.split('&');\n      for (let i = 0; i < pairs.length; i++) {\n        pair = pairs[i];\n        separatorIndex = pair.indexOf('=');\n        if (separatorIndex === -1) {\n          escapedKey = pair;\n          escapedValue = null;\n        } else {\n          escapedKey = pair.substr(0, separatorIndex);\n          escapedValue = pair.substr(separatorIndex + 1);\n        }\n        key = decodeURIComponent(escapedKey);\n        value = decodeURIComponent(escapedValue);\n        if (key.substr(0, 1) === '/') {\n          key = key.substr(1);\n        }\n        data[key] = value;\n      }\n      return data;\n    }\n  };\n  UrlHelperService = __decorate([Injectable()], UrlHelperService);\n  return UrlHelperService;\n})();\nclass OAuthEvent {\n  constructor(type) {\n    this.type = type;\n  }\n}\nclass OAuthSuccessEvent extends OAuthEvent {\n  constructor(type, info = null) {\n    super(type);\n    this.info = info;\n  }\n}\nclass OAuthInfoEvent extends OAuthEvent {\n  constructor(type, info = null) {\n    super(type);\n    this.info = info;\n  }\n}\nclass OAuthErrorEvent extends OAuthEvent {\n  constructor(type, reason, params = null) {\n    super(type);\n    this.reason = reason;\n    this.params = params;\n  }\n}\nclass AuthConfig {\n  constructor(json) {\n    /**\r\n     * The client's id as registered with the auth server\r\n     */\n    this.clientId = '';\n    /**\r\n     * The client's redirectUri as registered with the auth server\r\n     */\n    this.redirectUri = '';\n    /**\r\n     * An optional second redirectUri where the auth server\r\n     * redirects the user to after logging out.\r\n     */\n    this.postLogoutRedirectUri = '';\n    /**\r\n     * The auth server's endpoint that allows to log\r\n     * the user in when using implicit flow.\r\n     */\n    this.loginUrl = '';\n    /**\r\n     * The requested scopes\r\n     */\n    this.scope = 'openid profile';\n    this.resource = '';\n    this.rngUrl = '';\n    /**\r\n     * Defines whether to use OpenId Connect during\r\n     * implicit flow.\r\n     */\n    this.oidc = true;\n    /**\r\n     * Defines whether to request an access token during\r\n     * implicit flow.\r\n     */\n    this.requestAccessToken = true;\n    this.options = null;\n    /**\r\n     * The issuer's uri.\r\n     */\n    this.issuer = '';\n    /**\r\n     * The logout url.\r\n     */\n    this.logoutUrl = '';\n    /**\r\n     * Defines whether to clear the hash fragment after logging in.\r\n     */\n    this.clearHashAfterLogin = true;\n    /**\r\n     * Url of the token endpoint as defined by OpenId Connect and OAuth 2.\r\n     */\n    this.tokenEndpoint = null;\n    /**\r\n     * Url of the revocation endpoint as defined by OpenId Connect and OAuth 2.\r\n     */\n    this.revocationEndpoint = null;\n    /**\r\n     * Names of known parameters sent out in the TokenResponse. https://tools.ietf.org/html/rfc6749#section-5.1\r\n     */\n    this.customTokenParameters = [];\n    /**\r\n     * Url of the userinfo endpoint as defined by OpenId Connect.\r\n     */\n    this.userinfoEndpoint = null;\n    this.responseType = '';\n    /**\r\n     * Defines whether additional debug information should\r\n     * be shown at the console. Note that in certain browsers\r\n     * the verbosity of the console needs to be explicitly set\r\n     * to include Debug level messages.\r\n     */\n    this.showDebugInformation = false;\n    /**\r\n     * The redirect uri used when doing silent refresh.\r\n     */\n    this.silentRefreshRedirectUri = '';\n    this.silentRefreshMessagePrefix = '';\n    /**\r\n     * Set this to true to display the iframe used for\r\n     * silent refresh for debugging.\r\n     */\n    this.silentRefreshShowIFrame = false;\n    /**\r\n     * Timeout for silent refresh.\r\n     * @internal\r\n     * depreacted b/c of typo, see silentRefreshTimeout\r\n     */\n    this.siletRefreshTimeout = 1000 * 20;\n    /**\r\n     * Timeout for silent refresh.\r\n     */\n    this.silentRefreshTimeout = 1000 * 20;\n    /**\r\n     * Some auth servers don't allow using password flow\r\n     * w/o a client secret while the standards do not\r\n     * demand for it. In this case, you can set a password\r\n     * here. As this password is exposed to the public\r\n     * it does not bring additional security and is therefore\r\n     * as good as using no password.\r\n     */\n    this.dummyClientSecret = null;\n    /**\r\n     * Defines whether https is required.\r\n     * The default value is remoteOnly which only allows\r\n     * http for localhost, while every other domains need\r\n     * to be used with https.\r\n     */\n    this.requireHttps = 'remoteOnly';\n    /**\r\n     * Defines whether every url provided by the discovery\r\n     * document has to start with the issuer's url.\r\n     */\n    this.strictDiscoveryDocumentValidation = true;\n    /**\r\n     * JSON Web Key Set (https://tools.ietf.org/html/rfc7517)\r\n     * with keys used to validate received id_tokens.\r\n     * This is taken out of the disovery document. Can be set manually too.\r\n     */\n    this.jwks = null;\n    /**\r\n     * Map with additional query parameter that are appended to\r\n     * the request when initializing implicit flow.\r\n     */\n    this.customQueryParams = null;\n    this.silentRefreshIFrameName = 'angular-oauth-oidc-silent-refresh-iframe';\n    /**\r\n     * Defines when the token_timeout event should be raised.\r\n     * If you set this to the default value 0.75, the event\r\n     * is triggered after 75% of the token's life time.\r\n     */\n    this.timeoutFactor = 0.75;\n    /**\r\n     * If true, the lib will try to check whether the user\r\n     * is still logged in on a regular basis as described\r\n     * in http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification\r\n     */\n    this.sessionChecksEnabled = false;\n    /**\r\n     * Interval in msec for checking the session\r\n     * according to http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification\r\n     */\n    this.sessionCheckIntervall = 3 * 1000;\n    /**\r\n     * Url for the iframe used for session checks\r\n     */\n    this.sessionCheckIFrameUrl = null;\n    /**\r\n     * Name of the iframe to use for session checks\r\n     */\n    this.sessionCheckIFrameName = 'angular-oauth-oidc-check-session-iframe';\n    /**\r\n     * This property has been introduced to disable at_hash checks\r\n     * and is indented for Identity Provider that does not deliver\r\n     * an at_hash EVEN THOUGH its recommended by the OIDC specs.\r\n     * Of course, when disabling these checks the we are bypassing\r\n     * a security check which means we are more vulnerable.\r\n     */\n    this.disableAtHashCheck = false;\n    /**\r\n     * Defines wether to check the subject of a refreshed token after silent refresh.\r\n     * Normally, it should be the same as before.\r\n     */\n    this.skipSubjectCheck = false;\n    this.useIdTokenHintForSilentRefresh = false;\n    /**\r\n     * Defined whether to skip the validation of the issuer in the discovery document.\r\n     * Normally, the discovey document's url starts with the url of the issuer.\r\n     */\n    this.skipIssuerCheck = false;\n    /**\r\n     * final state sent to issuer is built as follows:\r\n     * state = nonce + nonceStateSeparator + additional state\r\n     * Default separator is ';' (encoded %3B).\r\n     * In rare cases, this character might be forbidden or inconvenient to use by the issuer so it can be customized.\r\n     */\n    this.nonceStateSeparator = ';';\n    /**\r\n     * Set this to true to use HTTP BASIC auth for AJAX calls\r\n     */\n    this.useHttpBasicAuth = false;\n    /**\r\n     * The interceptors waits this time span if there is no token\r\n     */\n    this.waitForTokenInMsec = 0;\n    /**\r\n     * Code Flow is by defauld used together with PKCI which is also higly recommented.\r\n     * You can disbale it here by setting this flag to true.\r\n     * https://tools.ietf.org/html/rfc7636#section-1.1\r\n     */\n    this.disablePKCE = false;\n    /**\r\n     * This property allows you to override the method that is used to open the login url,\r\n     * allowing a way for implementations to specify their own method of routing to new\r\n     * urls.\r\n     */\n    this.openUri = uri => {\n      location.href = uri;\n    };\n    if (json) {\n      Object.assign(this, json);\n    }\n  }\n}\n\n/**\r\n * This custom encoder allows charactes like +, % and / to be used in passwords\r\n */\nclass WebHttpUrlEncodingCodec {\n  encodeKey(k) {\n    return encodeURIComponent(k);\n  }\n  encodeValue(v) {\n    return encodeURIComponent(v);\n  }\n  decodeKey(k) {\n    return decodeURIComponent(k);\n  }\n  decodeValue(v) {\n    return decodeURIComponent(v);\n  }\n}\n\n/**\r\n * Abstraction for crypto algorithms\r\n */\nclass HashHandler {}\nlet DefaultHashHandler = /*#__PURE__*/(() => {\n  let DefaultHashHandler = class DefaultHashHandler {\n    calcHash(valueToHash, algorithm) {\n      return __awaiter(this, void 0, void 0, function* () {\n        // const encoder = new TextEncoder();\n        // const hashArray = await window.crypto.subtle.digest(algorithm, data);\n        // const data = encoder.encode(valueToHash);\n        const hashArray = sha256.array(valueToHash);\n        // const hashString = this.toHashString(hashArray);\n        const hashString = this.toHashString2(hashArray);\n        return hashString;\n      });\n    }\n    toHashString2(byteArray) {\n      let result = '';\n      for (let e of byteArray) {\n        result += String.fromCharCode(e);\n      }\n      return result;\n    }\n    toHashString(buffer) {\n      const byteArray = new Uint8Array(buffer);\n      let result = '';\n      for (let e of byteArray) {\n        result += String.fromCharCode(e);\n      }\n      return result;\n    }\n  };\n  DefaultHashHandler = __decorate([Injectable()], DefaultHashHandler);\n\n  /**\r\n   * Service for logging in and logging out with\r\n   * OIDC and OAuth2. Supports implicit flow and\r\n   * password flow.\r\n   */\n  return DefaultHashHandler;\n})();\nlet OAuthService = /*#__PURE__*/(() => {\n  let OAuthService = class OAuthService extends AuthConfig {\n    constructor(ngZone, http, storage, tokenValidationHandler, config, urlHelper, logger, crypto, document) {\n      var _a, _b, _c, _d;\n      super();\n      this.ngZone = ngZone;\n      this.http = http;\n      this.config = config;\n      this.urlHelper = urlHelper;\n      this.logger = logger;\n      this.crypto = crypto;\n      this.document = document;\n      /**\r\n       * @internal\r\n       * Deprecated:  use property events instead\r\n       */\n      this.discoveryDocumentLoaded = false;\n      /**\r\n       * The received (passed around) state, when logging\r\n       * in with implicit flow.\r\n       */\n      this.state = '';\n      this.eventsSubject = new Subject();\n      this.discoveryDocumentLoadedSubject = new Subject();\n      this.grantTypesSupported = [];\n      this.inImplicitFlow = false;\n      this.saveNoncesInLocalStorage = false;\n      this.debug('angular-oauth2-oidc v8-beta');\n      this.discoveryDocumentLoaded$ = this.discoveryDocumentLoadedSubject.asObservable();\n      this.events = this.eventsSubject.asObservable();\n      if (tokenValidationHandler) {\n        this.tokenValidationHandler = tokenValidationHandler;\n      }\n      if (config) {\n        this.configure(config);\n      }\n      try {\n        if (storage) {\n          this.setStorage(storage);\n        } else if (typeof sessionStorage !== 'undefined') {\n          this.setStorage(sessionStorage);\n        }\n      } catch (e) {\n        console.error('No OAuthStorage provided and cannot access default (sessionStorage).' + 'Consider providing a custom OAuthStorage implementation in your module.', e);\n      }\n      // in IE, sessionStorage does not always survive a redirect\n      if (typeof window !== 'undefined' && typeof window['localStorage'] !== 'undefined') {\n        const ua = (_b = (_a = window) === null || _a === void 0 ? void 0 : _a.navigator) === null || _b === void 0 ? void 0 : _b.userAgent;\n        const msie = ((_c = ua) === null || _c === void 0 ? void 0 : _c.includes('MSIE ')) || ((_d = ua) === null || _d === void 0 ? void 0 : _d.includes('Trident'));\n        if (msie) {\n          this.saveNoncesInLocalStorage = true;\n        }\n      }\n      this.setupRefreshTimer();\n    }\n    /**\r\n     * Use this method to configure the service\r\n     * @param config the configuration\r\n     */\n    configure(config) {\n      // For the sake of downward compatibility with\n      // original configuration API\n      Object.assign(this, new AuthConfig(), config);\n      this.config = Object.assign({}, new AuthConfig(), config);\n      if (this.sessionChecksEnabled) {\n        this.setupSessionCheck();\n      }\n      this.configChanged();\n    }\n    configChanged() {\n      this.setupRefreshTimer();\n    }\n    restartSessionChecksIfStillLoggedIn() {\n      if (this.hasValidIdToken()) {\n        this.initSessionCheck();\n      }\n    }\n    restartRefreshTimerIfStillLoggedIn() {\n      this.setupExpirationTimers();\n    }\n    setupSessionCheck() {\n      this.events.pipe(filter(e => e.type === 'token_received')).subscribe(e => {\n        this.initSessionCheck();\n      });\n    }\n    /**\r\n     * Will setup up silent refreshing for when the token is\r\n     * about to expire. When the user is logged out via this.logOut method, the\r\n     * silent refreshing will pause and not refresh the tokens until the user is\r\n     * logged back in via receiving a new token.\r\n     * @param params Additional parameter to pass\r\n     * @param listenTo Setup automatic refresh of a specific token type\r\n     */\n    setupAutomaticSilentRefresh(params = {}, listenTo, noPrompt = true) {\n      let shouldRunSilentRefresh = true;\n      this.events.pipe(tap(e => {\n        if (e.type === 'token_received') {\n          shouldRunSilentRefresh = true;\n        } else if (e.type === 'logout') {\n          shouldRunSilentRefresh = false;\n        }\n      }), filter(e => e.type === 'token_expires'), debounceTime(1000)).subscribe(e => {\n        const event = e;\n        if ((listenTo == null || listenTo === 'any' || event.info === listenTo) && shouldRunSilentRefresh) {\n          // this.silentRefresh(params, noPrompt).catch(_ => {\n          this.refreshInternal(params, noPrompt).catch(_ => {\n            this.debug('Automatic silent refresh did not work');\n          });\n        }\n      });\n      this.restartRefreshTimerIfStillLoggedIn();\n    }\n    refreshInternal(params, noPrompt) {\n      if (!this.useSilentRefresh && this.responseType === 'code') {\n        return this.refreshToken();\n      } else {\n        return this.silentRefresh(params, noPrompt);\n      }\n    }\n    /**\r\n     * Convenience method that first calls `loadDiscoveryDocument(...)` and\r\n     * directly chains using the `then(...)` part of the promise to call\r\n     * the `tryLogin(...)` method.\r\n     *\r\n     * @param options LoginOptions to pass through to `tryLogin(...)`\r\n     */\n    loadDiscoveryDocumentAndTryLogin(options = null) {\n      return this.loadDiscoveryDocument().then(doc => {\n        return this.tryLogin(options);\n      });\n    }\n    /**\r\n     * Convenience method that first calls `loadDiscoveryDocumentAndTryLogin(...)`\r\n     * and if then chains to `initLoginFlow()`, but only if there is no valid\r\n     * IdToken or no valid AccessToken.\r\n     *\r\n     * @param options LoginOptions to pass through to `tryLogin(...)`\r\n     */\n    loadDiscoveryDocumentAndLogin(options = null) {\n      if (!options) {\n        options = {\n          state: ''\n        };\n      }\n      return this.loadDiscoveryDocumentAndTryLogin(options).then(_ => {\n        if (!this.hasValidIdToken() || !this.hasValidAccessToken()) {\n          if (this.responseType === 'code') {\n            this.initCodeFlow();\n          } else {\n            this.initImplicitFlow();\n          }\n          return false;\n        } else {\n          return true;\n        }\n      });\n    }\n    debug(...args) {\n      if (this.showDebugInformation) {\n        this.logger.debug.apply(this.logger, args);\n      }\n    }\n    validateUrlFromDiscoveryDocument(url) {\n      const errors = [];\n      const httpsCheck = this.validateUrlForHttps(url);\n      const issuerCheck = this.validateUrlAgainstIssuer(url);\n      if (!httpsCheck) {\n        errors.push('https for all urls required. Also for urls received by discovery.');\n      }\n      if (!issuerCheck) {\n        errors.push('Every url in discovery document has to start with the issuer url.' + 'Also see property strictDiscoveryDocumentValidation.');\n      }\n      return errors;\n    }\n    validateUrlForHttps(url) {\n      if (!url) {\n        return true;\n      }\n      const lcUrl = url.toLowerCase();\n      if (this.requireHttps === false) {\n        return true;\n      }\n      if ((lcUrl.match(/^http:\\/\\/localhost($|[:\\/])/) || lcUrl.match(/^http:\\/\\/localhost($|[:\\/])/)) && this.requireHttps === 'remoteOnly') {\n        return true;\n      }\n      return lcUrl.startsWith('https://');\n    }\n    assertUrlNotNullAndCorrectProtocol(url, description) {\n      if (!url) {\n        throw new Error(`'${description}' should not be null`);\n      }\n      if (!this.validateUrlForHttps(url)) {\n        throw new Error(`'${description}' must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).`);\n      }\n    }\n    validateUrlAgainstIssuer(url) {\n      if (!this.strictDiscoveryDocumentValidation) {\n        return true;\n      }\n      if (!url) {\n        return true;\n      }\n      return url.toLowerCase().startsWith(this.issuer.toLowerCase());\n    }\n    setupRefreshTimer() {\n      if (typeof window === 'undefined') {\n        this.debug('timer not supported on this plattform');\n        return;\n      }\n      if (this.hasValidIdToken() || this.hasValidAccessToken()) {\n        this.clearAccessTokenTimer();\n        this.clearIdTokenTimer();\n        this.setupExpirationTimers();\n      }\n      if (this.tokenReceivedSubscription) this.tokenReceivedSubscription.unsubscribe();\n      this.tokenReceivedSubscription = this.events.pipe(filter(e => e.type === 'token_received')).subscribe(_ => {\n        this.clearAccessTokenTimer();\n        this.clearIdTokenTimer();\n        this.setupExpirationTimers();\n      });\n    }\n    setupExpirationTimers() {\n      if (this.hasValidAccessToken()) {\n        this.setupAccessTokenTimer();\n      }\n      if (this.hasValidIdToken()) {\n        this.setupIdTokenTimer();\n      }\n    }\n    setupAccessTokenTimer() {\n      const expiration = this.getAccessTokenExpiration();\n      const storedAt = this.getAccessTokenStoredAt();\n      const timeout = this.calcTimeout(storedAt, expiration);\n      this.ngZone.runOutsideAngular(() => {\n        this.accessTokenTimeoutSubscription = of(new OAuthInfoEvent('token_expires', 'access_token')).pipe(delay(timeout)).subscribe(e => {\n          this.ngZone.run(() => {\n            this.eventsSubject.next(e);\n          });\n        });\n      });\n    }\n    setupIdTokenTimer() {\n      const expiration = this.getIdTokenExpiration();\n      const storedAt = this.getIdTokenStoredAt();\n      const timeout = this.calcTimeout(storedAt, expiration);\n      this.ngZone.runOutsideAngular(() => {\n        this.idTokenTimeoutSubscription = of(new OAuthInfoEvent('token_expires', 'id_token')).pipe(delay(timeout)).subscribe(e => {\n          this.ngZone.run(() => {\n            this.eventsSubject.next(e);\n          });\n        });\n      });\n    }\n    /**\r\n     * Stops timers for automatic refresh.\r\n     * To restart it, call setupAutomaticSilentRefresh again.\r\n     */\n    stopAutomaticRefresh() {\n      this.clearAccessTokenTimer();\n      this.clearIdTokenTimer();\n    }\n    clearAccessTokenTimer() {\n      if (this.accessTokenTimeoutSubscription) {\n        this.accessTokenTimeoutSubscription.unsubscribe();\n      }\n    }\n    clearIdTokenTimer() {\n      if (this.idTokenTimeoutSubscription) {\n        this.idTokenTimeoutSubscription.unsubscribe();\n      }\n    }\n    calcTimeout(storedAt, expiration) {\n      const now = Date.now();\n      const delta = (expiration - storedAt) * this.timeoutFactor - (now - storedAt);\n      return Math.max(0, delta);\n    }\n    /**\r\n     * DEPRECATED. Use a provider for OAuthStorage instead:\r\n     *\r\n     * { provide: OAuthStorage, useFactory: oAuthStorageFactory }\r\n     * export function oAuthStorageFactory(): OAuthStorage { return localStorage; }\r\n     * Sets a custom storage used to store the received\r\n     * tokens on client side. By default, the browser's\r\n     * sessionStorage is used.\r\n     * @ignore\r\n     *\r\n     * @param storage\r\n     */\n    setStorage(storage) {\n      this._storage = storage;\n      this.configChanged();\n    }\n    /**\r\n     * Loads the discovery document to configure most\r\n     * properties of this service. The url of the discovery\r\n     * document is infered from the issuer's url according\r\n     * to the OpenId Connect spec. To use another url you\r\n     * can pass it to to optional parameter fullUrl.\r\n     *\r\n     * @param fullUrl\r\n     */\n    loadDiscoveryDocument(fullUrl = null) {\n      return new Promise((resolve, reject) => {\n        if (!fullUrl) {\n          fullUrl = this.issuer || '';\n          if (!fullUrl.endsWith('/')) {\n            fullUrl += '/';\n          }\n          fullUrl += '.well-known/openid-configuration';\n        }\n        if (!this.validateUrlForHttps(fullUrl)) {\n          reject(\"issuer  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n          return;\n        }\n        this.http.get(fullUrl).subscribe(doc => {\n          if (!this.validateDiscoveryDocument(doc)) {\n            this.eventsSubject.next(new OAuthErrorEvent('discovery_document_validation_error', null));\n            reject('discovery_document_validation_error');\n            return;\n          }\n          this.loginUrl = doc.authorization_endpoint;\n          this.logoutUrl = doc.end_session_endpoint || this.logoutUrl;\n          this.grantTypesSupported = doc.grant_types_supported;\n          this.issuer = doc.issuer;\n          this.tokenEndpoint = doc.token_endpoint;\n          this.userinfoEndpoint = doc.userinfo_endpoint || this.userinfoEndpoint;\n          this.jwksUri = doc.jwks_uri;\n          this.sessionCheckIFrameUrl = doc.check_session_iframe || this.sessionCheckIFrameUrl;\n          this.discoveryDocumentLoaded = true;\n          this.discoveryDocumentLoadedSubject.next(doc);\n          this.revocationEndpoint = doc.revocation_endpoint;\n          if (this.sessionChecksEnabled) {\n            this.restartSessionChecksIfStillLoggedIn();\n          }\n          this.loadJwks().then(jwks => {\n            const result = {\n              discoveryDocument: doc,\n              jwks: jwks\n            };\n            const event = new OAuthSuccessEvent('discovery_document_loaded', result);\n            this.eventsSubject.next(event);\n            resolve(event);\n            return;\n          }).catch(err => {\n            this.eventsSubject.next(new OAuthErrorEvent('discovery_document_load_error', err));\n            reject(err);\n            return;\n          });\n        }, err => {\n          this.logger.error('error loading discovery document', err);\n          this.eventsSubject.next(new OAuthErrorEvent('discovery_document_load_error', err));\n          reject(err);\n        });\n      });\n    }\n    loadJwks() {\n      return new Promise((resolve, reject) => {\n        if (this.jwksUri) {\n          this.http.get(this.jwksUri).subscribe(jwks => {\n            this.jwks = jwks;\n            this.eventsSubject.next(new OAuthSuccessEvent('discovery_document_loaded'));\n            resolve(jwks);\n          }, err => {\n            this.logger.error('error loading jwks', err);\n            this.eventsSubject.next(new OAuthErrorEvent('jwks_load_error', err));\n            reject(err);\n          });\n        } else {\n          resolve(null);\n        }\n      });\n    }\n    validateDiscoveryDocument(doc) {\n      let errors;\n      if (!this.skipIssuerCheck && doc.issuer !== this.issuer) {\n        this.logger.error('invalid issuer in discovery document', 'expected: ' + this.issuer, 'current: ' + doc.issuer);\n        return false;\n      }\n      errors = this.validateUrlFromDiscoveryDocument(doc.authorization_endpoint);\n      if (errors.length > 0) {\n        this.logger.error('error validating authorization_endpoint in discovery document', errors);\n        return false;\n      }\n      errors = this.validateUrlFromDiscoveryDocument(doc.end_session_endpoint);\n      if (errors.length > 0) {\n        this.logger.error('error validating end_session_endpoint in discovery document', errors);\n        return false;\n      }\n      errors = this.validateUrlFromDiscoveryDocument(doc.token_endpoint);\n      if (errors.length > 0) {\n        this.logger.error('error validating token_endpoint in discovery document', errors);\n      }\n      errors = this.validateUrlFromDiscoveryDocument(doc.revocation_endpoint);\n      if (errors.length > 0) {\n        this.logger.error('error validating revocation_endpoint in discovery document', errors);\n      }\n      errors = this.validateUrlFromDiscoveryDocument(doc.userinfo_endpoint);\n      if (errors.length > 0) {\n        this.logger.error('error validating userinfo_endpoint in discovery document', errors);\n        return false;\n      }\n      errors = this.validateUrlFromDiscoveryDocument(doc.jwks_uri);\n      if (errors.length > 0) {\n        this.logger.error('error validating jwks_uri in discovery document', errors);\n        return false;\n      }\n      if (this.sessionChecksEnabled && !doc.check_session_iframe) {\n        this.logger.warn('sessionChecksEnabled is activated but discovery document' + ' does not contain a check_session_iframe field');\n      }\n      return true;\n    }\n    /**\r\n     * Uses password flow to exchange userName and password for an\r\n     * access_token. After receiving the access_token, this method\r\n     * uses it to query the userinfo endpoint in order to get information\r\n     * about the user in question.\r\n     *\r\n     * When using this, make sure that the property oidc is set to false.\r\n     * Otherwise stricter validations take place that make this operation\r\n     * fail.\r\n     *\r\n     * @param userName\r\n     * @param password\r\n     * @param headers Optional additional http-headers.\r\n     */\n    fetchTokenUsingPasswordFlowAndLoadUserProfile(userName, password, headers = new HttpHeaders()) {\n      return this.fetchTokenUsingPasswordFlow(userName, password, headers).then(() => this.loadUserProfile());\n    }\n    /**\r\n     * Loads the user profile by accessing the user info endpoint defined by OpenId Connect.\r\n     *\r\n     * When using this with OAuth2 password flow, make sure that the property oidc is set to false.\r\n     * Otherwise stricter validations take place that make this operation fail.\r\n     */\n    loadUserProfile() {\n      if (!this.hasValidAccessToken()) {\n        throw new Error('Can not load User Profile without access_token');\n      }\n      if (!this.validateUrlForHttps(this.userinfoEndpoint)) {\n        throw new Error(\"userinfoEndpoint must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n      }\n      return new Promise((resolve, reject) => {\n        const headers = new HttpHeaders().set('Authorization', 'Bearer ' + this.getAccessToken());\n        this.http.get(this.userinfoEndpoint, {\n          headers\n        }).subscribe(info => {\n          this.debug('userinfo received', info);\n          const existingClaims = this.getIdentityClaims() || {};\n          if (!this.skipSubjectCheck) {\n            if (this.oidc && (!existingClaims['sub'] || info.sub !== existingClaims['sub'])) {\n              const err = 'if property oidc is true, the received user-id (sub) has to be the user-id ' + 'of the user that has logged in with oidc.\\n' + 'if you are not using oidc but just oauth2 password flow set oidc to false';\n              reject(err);\n              return;\n            }\n          }\n          info = Object.assign({}, existingClaims, info);\n          this._storage.setItem('id_token_claims_obj', JSON.stringify(info));\n          this.eventsSubject.next(new OAuthSuccessEvent('user_profile_loaded'));\n          resolve(info);\n        }, err => {\n          this.logger.error('error loading user info', err);\n          this.eventsSubject.next(new OAuthErrorEvent('user_profile_load_error', err));\n          reject(err);\n        });\n      });\n    }\n    /**\r\n     * Uses password flow to exchange userName and password for an access_token.\r\n     * @param userName\r\n     * @param password\r\n     * @param headers Optional additional http-headers.\r\n     */\n    fetchTokenUsingPasswordFlow(userName, password, headers = new HttpHeaders()) {\n      this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint, 'tokenEndpoint');\n      return new Promise((resolve, reject) => {\n        /**\r\n         * A `HttpParameterCodec` that uses `encodeURIComponent` and `decodeURIComponent` to\r\n         * serialize and parse URL parameter keys and values.\r\n         *\r\n         * @stable\r\n         */\n        let params = new HttpParams({\n          encoder: new WebHttpUrlEncodingCodec()\n        }).set('grant_type', 'password').set('scope', this.scope).set('username', userName).set('password', password);\n        if (this.useHttpBasicAuth) {\n          const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n          headers = headers.set('Authorization', 'Basic ' + header);\n        }\n        if (!this.useHttpBasicAuth) {\n          params = params.set('client_id', this.clientId);\n        }\n        if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n          params = params.set('client_secret', this.dummyClientSecret);\n        }\n        if (this.customQueryParams) {\n          for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n            params = params.set(key, this.customQueryParams[key]);\n          }\n        }\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n        this.http.post(this.tokenEndpoint, params, {\n          headers\n        }).subscribe(tokenResponse => {\n          this.debug('tokenResponse', tokenResponse);\n          this.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in || this.fallbackAccessTokenExpirationTimeInSec, tokenResponse.scope, this.extractRecognizedCustomParameters(tokenResponse));\n          this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n          resolve(tokenResponse);\n        }, err => {\n          this.logger.error('Error performing password flow', err);\n          this.eventsSubject.next(new OAuthErrorEvent('token_error', err));\n          reject(err);\n        });\n      });\n    }\n    /**\r\n     * Refreshes the token using a refresh_token.\r\n     * This does not work for implicit flow, b/c\r\n     * there is no refresh_token in this flow.\r\n     * A solution for this is provided by the\r\n     * method silentRefresh.\r\n     */\n    refreshToken() {\n      this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint, 'tokenEndpoint');\n      return new Promise((resolve, reject) => {\n        let params = new HttpParams().set('grant_type', 'refresh_token').set('scope', this.scope).set('refresh_token', this._storage.getItem('refresh_token'));\n        let headers = new HttpHeaders().set('Content-Type', 'application/x-www-form-urlencoded');\n        if (this.useHttpBasicAuth) {\n          const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n          headers = headers.set('Authorization', 'Basic ' + header);\n        }\n        if (!this.useHttpBasicAuth) {\n          params = params.set('client_id', this.clientId);\n        }\n        if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n          params = params.set('client_secret', this.dummyClientSecret);\n        }\n        if (this.customQueryParams) {\n          for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n            params = params.set(key, this.customQueryParams[key]);\n          }\n        }\n        this.http.post(this.tokenEndpoint, params, {\n          headers\n        }).pipe(switchMap(tokenResponse => {\n          if (tokenResponse.id_token) {\n            return from(this.processIdToken(tokenResponse.id_token, tokenResponse.access_token, true)).pipe(tap(result => this.storeIdToken(result)), map(_ => tokenResponse));\n          } else {\n            return of(tokenResponse);\n          }\n        })).subscribe(tokenResponse => {\n          this.debug('refresh tokenResponse', tokenResponse);\n          this.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in || this.fallbackAccessTokenExpirationTimeInSec, tokenResponse.scope, this.extractRecognizedCustomParameters(tokenResponse));\n          this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n          this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n          resolve(tokenResponse);\n        }, err => {\n          this.logger.error('Error refreshing token', err);\n          this.eventsSubject.next(new OAuthErrorEvent('token_refresh_error', err));\n          reject(err);\n        });\n      });\n    }\n    removeSilentRefreshEventListener() {\n      if (this.silentRefreshPostMessageEventListener) {\n        window.removeEventListener('message', this.silentRefreshPostMessageEventListener);\n        this.silentRefreshPostMessageEventListener = null;\n      }\n    }\n    setupSilentRefreshEventListener() {\n      this.removeSilentRefreshEventListener();\n      this.silentRefreshPostMessageEventListener = e => {\n        const message = this.processMessageEventMessage(e);\n        this.tryLogin({\n          customHashFragment: message,\n          preventClearHashAfterLogin: true,\n          customRedirectUri: this.silentRefreshRedirectUri || this.redirectUri\n        }).catch(err => this.debug('tryLogin during silent refresh failed', err));\n      };\n      window.addEventListener('message', this.silentRefreshPostMessageEventListener);\n    }\n    /**\r\n     * Performs a silent refresh for implicit flow.\r\n     * Use this method to get new tokens when/before\r\n     * the existing tokens expire.\r\n     */\n    silentRefresh(params = {}, noPrompt = true) {\n      const claims = this.getIdentityClaims() || {};\n      if (this.useIdTokenHintForSilentRefresh && this.hasValidIdToken()) {\n        params['id_token_hint'] = this.getIdToken();\n      }\n      if (!this.validateUrlForHttps(this.loginUrl)) {\n        throw new Error(\"loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n      }\n      if (typeof document === 'undefined') {\n        throw new Error('silent refresh is not supported on this platform');\n      }\n      const existingIframe = document.getElementById(this.silentRefreshIFrameName);\n      if (existingIframe) {\n        document.body.removeChild(existingIframe);\n      }\n      this.silentRefreshSubject = claims['sub'];\n      const iframe = document.createElement('iframe');\n      iframe.id = this.silentRefreshIFrameName;\n      this.setupSilentRefreshEventListener();\n      const redirectUri = this.silentRefreshRedirectUri || this.redirectUri;\n      this.createLoginUrl(null, null, redirectUri, noPrompt, params).then(url => {\n        iframe.setAttribute('src', url);\n        if (!this.silentRefreshShowIFrame) {\n          iframe.style['display'] = 'none';\n        }\n        document.body.appendChild(iframe);\n      });\n      const errors = this.events.pipe(filter(e => e instanceof OAuthErrorEvent), first());\n      const success = this.events.pipe(filter(e => e.type === 'token_received'), first());\n      const timeout = of(new OAuthErrorEvent('silent_refresh_timeout', null)).pipe(delay(this.silentRefreshTimeout));\n      return race([errors, success, timeout]).pipe(map(e => {\n        if (e instanceof OAuthErrorEvent) {\n          if (e.type === 'silent_refresh_timeout') {\n            this.eventsSubject.next(e);\n          } else {\n            e = new OAuthErrorEvent('silent_refresh_error', e);\n            this.eventsSubject.next(e);\n          }\n          throw e;\n        } else if (e.type === 'token_received') {\n          e = new OAuthSuccessEvent('silently_refreshed');\n          this.eventsSubject.next(e);\n        }\n        return e;\n      })).toPromise();\n    }\n    /**\r\n     * This method exists for backwards compatibility.\r\n     * {@link OAuthService#initLoginFlowInPopup} handles both code\r\n     * and implicit flows.\r\n     */\n    initImplicitFlowInPopup(options) {\n      return this.initLoginFlowInPopup(options);\n    }\n    initLoginFlowInPopup(options) {\n      options = options || {};\n      return this.createLoginUrl(null, null, this.silentRefreshRedirectUri, false, {\n        display: 'popup'\n      }).then(url => {\n        return new Promise((resolve, reject) => {\n          /**\r\n           * Error handling section\r\n           */\n          const checkForPopupClosedInterval = 500;\n          let windowRef = window.open(url, '_blank', this.calculatePopupFeatures(options));\n          let checkForPopupClosedTimer;\n          const checkForPopupClosed = () => {\n            if (!windowRef || windowRef.closed) {\n              cleanup();\n              reject(new OAuthErrorEvent('popup_closed', {}));\n            }\n          };\n          if (!windowRef) {\n            reject(new OAuthErrorEvent('popup_blocked', {}));\n          } else {\n            checkForPopupClosedTimer = window.setInterval(checkForPopupClosed, checkForPopupClosedInterval);\n          }\n          const cleanup = () => {\n            window.clearInterval(checkForPopupClosedTimer);\n            window.removeEventListener('message', listener);\n            if (windowRef !== null) {\n              windowRef.close();\n            }\n            windowRef = null;\n          };\n          const listener = e => {\n            const message = this.processMessageEventMessage(e);\n            if (message && message !== null) {\n              this.tryLogin({\n                customHashFragment: message,\n                preventClearHashAfterLogin: true,\n                customRedirectUri: this.silentRefreshRedirectUri\n              }).then(() => {\n                cleanup();\n                resolve();\n              }, err => {\n                cleanup();\n                reject(err);\n              });\n            } else {\n              console.log('false event firing');\n            }\n          };\n          window.addEventListener('message', listener);\n        });\n      });\n    }\n    calculatePopupFeatures(options) {\n      // Specify an static height and width and calculate centered position\n      const height = options.height || 470;\n      const width = options.width || 500;\n      const left = window.screenLeft + (window.outerWidth - width) / 2;\n      const top = window.screenTop + (window.outerHeight - height) / 2;\n      return `location=no,toolbar=no,width=${width},height=${height},top=${top},left=${left}`;\n    }\n    processMessageEventMessage(e) {\n      let expectedPrefix = '#';\n      if (this.silentRefreshMessagePrefix) {\n        expectedPrefix += this.silentRefreshMessagePrefix;\n      }\n      if (!e || !e.data || typeof e.data !== 'string') {\n        return;\n      }\n      const prefixedMessage = e.data;\n      if (!prefixedMessage.startsWith(expectedPrefix)) {\n        return;\n      }\n      return '#' + prefixedMessage.substr(expectedPrefix.length);\n    }\n    canPerformSessionCheck() {\n      if (!this.sessionChecksEnabled) {\n        return false;\n      }\n      if (!this.sessionCheckIFrameUrl) {\n        console.warn('sessionChecksEnabled is activated but there is no sessionCheckIFrameUrl');\n        return false;\n      }\n      const sessionState = this.getSessionState();\n      if (!sessionState) {\n        console.warn('sessionChecksEnabled is activated but there is no session_state');\n        return false;\n      }\n      if (typeof document === 'undefined') {\n        return false;\n      }\n      return true;\n    }\n    setupSessionCheckEventListener() {\n      this.removeSessionCheckEventListener();\n      this.sessionCheckEventListener = e => {\n        const origin = e.origin.toLowerCase();\n        const issuer = this.issuer.toLowerCase();\n        this.debug('sessionCheckEventListener');\n        if (!issuer.startsWith(origin)) {\n          this.debug('sessionCheckEventListener', 'wrong origin', origin, 'expected', issuer, 'event', e);\n          return;\n        }\n        // only run in Angular zone if it is 'changed' or 'error'\n        switch (e.data) {\n          case 'unchanged':\n            this.handleSessionUnchanged();\n            break;\n          case 'changed':\n            this.ngZone.run(() => {\n              this.handleSessionChange();\n            });\n            break;\n          case 'error':\n            this.ngZone.run(() => {\n              this.handleSessionError();\n            });\n            break;\n        }\n        this.debug('got info from session check inframe', e);\n      };\n      // prevent Angular from refreshing the view on every message (runs in intervals)\n      this.ngZone.runOutsideAngular(() => {\n        window.addEventListener('message', this.sessionCheckEventListener);\n      });\n    }\n    handleSessionUnchanged() {\n      this.debug('session check', 'session unchanged');\n    }\n    handleSessionChange() {\n      this.eventsSubject.next(new OAuthInfoEvent('session_changed'));\n      this.stopSessionCheckTimer();\n      if (!this.useSilentRefresh && this.responseType === 'code') {\n        this.refreshToken().then(_ => {\n          this.debug('token refresh after session change worked');\n        }).catch(_ => {\n          this.debug('token refresh did not work after session changed');\n          this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n          this.logOut(true);\n        });\n      } else if (this.silentRefreshRedirectUri) {\n        this.silentRefresh().catch(_ => this.debug('silent refresh failed after session changed'));\n        this.waitForSilentRefreshAfterSessionChange();\n      } else {\n        this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n        this.logOut(true);\n      }\n    }\n    waitForSilentRefreshAfterSessionChange() {\n      this.events.pipe(filter(e => e.type === 'silently_refreshed' || e.type === 'silent_refresh_timeout' || e.type === 'silent_refresh_error'), first()).subscribe(e => {\n        if (e.type !== 'silently_refreshed') {\n          this.debug('silent refresh did not work after session changed');\n          this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n          this.logOut(true);\n        }\n      });\n    }\n    handleSessionError() {\n      this.stopSessionCheckTimer();\n      this.eventsSubject.next(new OAuthInfoEvent('session_error'));\n    }\n    removeSessionCheckEventListener() {\n      if (this.sessionCheckEventListener) {\n        window.removeEventListener('message', this.sessionCheckEventListener);\n        this.sessionCheckEventListener = null;\n      }\n    }\n    initSessionCheck() {\n      if (!this.canPerformSessionCheck()) {\n        return;\n      }\n      const existingIframe = document.getElementById(this.sessionCheckIFrameName);\n      if (existingIframe) {\n        document.body.removeChild(existingIframe);\n      }\n      const iframe = document.createElement('iframe');\n      iframe.id = this.sessionCheckIFrameName;\n      this.setupSessionCheckEventListener();\n      const url = this.sessionCheckIFrameUrl;\n      iframe.setAttribute('src', url);\n      iframe.style.display = 'none';\n      document.body.appendChild(iframe);\n      this.startSessionCheckTimer();\n    }\n    startSessionCheckTimer() {\n      this.stopSessionCheckTimer();\n      this.ngZone.runOutsideAngular(() => {\n        this.sessionCheckTimer = setInterval(this.checkSession.bind(this), this.sessionCheckIntervall);\n      });\n    }\n    stopSessionCheckTimer() {\n      if (this.sessionCheckTimer) {\n        clearInterval(this.sessionCheckTimer);\n        this.sessionCheckTimer = null;\n      }\n    }\n    checkSession() {\n      const iframe = document.getElementById(this.sessionCheckIFrameName);\n      if (!iframe) {\n        this.logger.warn('checkSession did not find iframe', this.sessionCheckIFrameName);\n      }\n      const sessionState = this.getSessionState();\n      if (!sessionState) {\n        this.stopSessionCheckTimer();\n      }\n      const message = this.clientId + ' ' + sessionState;\n      iframe.contentWindow.postMessage(message, this.issuer);\n    }\n    createLoginUrl(state = '', loginHint = '', customRedirectUri = '', noPrompt = false, params = {}) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const that = this;\n        let redirectUri;\n        if (customRedirectUri) {\n          redirectUri = customRedirectUri;\n        } else {\n          redirectUri = this.redirectUri;\n        }\n        const nonce = yield this.createAndSaveNonce();\n        if (state) {\n          state = nonce + this.config.nonceStateSeparator + encodeURIComponent(state);\n        } else {\n          state = nonce;\n        }\n        if (!this.requestAccessToken && !this.oidc) {\n          throw new Error('Either requestAccessToken or oidc or both must be true');\n        }\n        if (this.config.responseType) {\n          this.responseType = this.config.responseType;\n        } else {\n          if (this.oidc && this.requestAccessToken) {\n            this.responseType = 'id_token token';\n          } else if (this.oidc && !this.requestAccessToken) {\n            this.responseType = 'id_token';\n          } else {\n            this.responseType = 'token';\n          }\n        }\n        const seperationChar = that.loginUrl.indexOf('?') > -1 ? '&' : '?';\n        let scope = that.scope;\n        if (this.oidc && !scope.match(/(^|\\s)openid($|\\s)/)) {\n          scope = 'openid ' + scope;\n        }\n        let url = that.loginUrl + seperationChar + 'response_type=' + encodeURIComponent(that.responseType) + '&client_id=' + encodeURIComponent(that.clientId) + '&state=' + encodeURIComponent(state) + '&redirect_uri=' + encodeURIComponent(redirectUri) + '&scope=' + encodeURIComponent(scope);\n        if (this.responseType === 'code' && !this.disablePKCE) {\n          const [challenge, verifier] = yield this.createChallangeVerifierPairForPKCE();\n          if (this.saveNoncesInLocalStorage && typeof window['localStorage'] !== 'undefined') {\n            localStorage.setItem('PKCI_verifier', verifier);\n          } else {\n            this._storage.setItem('PKCI_verifier', verifier);\n          }\n          url += '&code_challenge=' + challenge;\n          url += '&code_challenge_method=S256';\n        }\n        if (loginHint) {\n          url += '&login_hint=' + encodeURIComponent(loginHint);\n        }\n        if (that.resource) {\n          url += '&resource=' + encodeURIComponent(that.resource);\n        }\n        if (that.oidc) {\n          url += '&nonce=' + encodeURIComponent(nonce);\n        }\n        if (noPrompt) {\n          url += '&prompt=none';\n        }\n        for (const key of Object.keys(params)) {\n          url += '&' + encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\n        }\n        if (this.customQueryParams) {\n          for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n            url += '&' + key + '=' + encodeURIComponent(this.customQueryParams[key]);\n          }\n        }\n        return url;\n      });\n    }\n    initImplicitFlowInternal(additionalState = '', params = '') {\n      if (this.inImplicitFlow) {\n        return;\n      }\n      this.inImplicitFlow = true;\n      if (!this.validateUrlForHttps(this.loginUrl)) {\n        throw new Error(\"loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n      }\n      let addParams = {};\n      let loginHint = null;\n      if (typeof params === 'string') {\n        loginHint = params;\n      } else if (typeof params === 'object') {\n        addParams = params;\n      }\n      this.createLoginUrl(additionalState, loginHint, null, false, addParams).then(this.config.openUri).catch(error => {\n        console.error('Error in initImplicitFlow', error);\n        this.inImplicitFlow = false;\n      });\n    }\n    /**\r\n     * Starts the implicit flow and redirects to user to\r\n     * the auth servers' login url.\r\n     *\r\n     * @param additionalState Optional state that is passed around.\r\n     *  You'll find this state in the property `state` after `tryLogin` logged in the user.\r\n     * @param params Hash with additional parameter. If it is a string, it is used for the\r\n     *               parameter loginHint (for the sake of compatibility with former versions)\r\n     */\n    initImplicitFlow(additionalState = '', params = '') {\n      if (this.loginUrl !== '') {\n        this.initImplicitFlowInternal(additionalState, params);\n      } else {\n        this.events.pipe(filter(e => e.type === 'discovery_document_loaded')).subscribe(_ => this.initImplicitFlowInternal(additionalState, params));\n      }\n    }\n    /**\r\n     * Reset current implicit flow\r\n     *\r\n     * @description This method allows resetting the current implict flow in order to be initialized again.\r\n     */\n    resetImplicitFlow() {\n      this.inImplicitFlow = false;\n    }\n    callOnTokenReceivedIfExists(options) {\n      const that = this;\n      if (options.onTokenReceived) {\n        const tokenParams = {\n          idClaims: that.getIdentityClaims(),\n          idToken: that.getIdToken(),\n          accessToken: that.getAccessToken(),\n          state: that.state\n        };\n        options.onTokenReceived(tokenParams);\n      }\n    }\n    storeAccessTokenResponse(accessToken, refreshToken, expiresIn, grantedScopes, customParameters) {\n      this._storage.setItem('access_token', accessToken);\n      if (grantedScopes && !Array.isArray(grantedScopes)) {\n        this._storage.setItem('granted_scopes', JSON.stringify(grantedScopes.split('+')));\n      } else if (grantedScopes && Array.isArray(grantedScopes)) {\n        this._storage.setItem('granted_scopes', JSON.stringify(grantedScopes));\n      }\n      this._storage.setItem('access_token_stored_at', '' + Date.now());\n      if (expiresIn) {\n        const expiresInMilliSeconds = expiresIn * 1000;\n        const now = new Date();\n        const expiresAt = now.getTime() + expiresInMilliSeconds;\n        this._storage.setItem('expires_at', '' + expiresAt);\n      }\n      if (refreshToken) {\n        this._storage.setItem('refresh_token', refreshToken);\n      }\n      if (customParameters) {\n        customParameters.forEach((value, key) => {\n          this._storage.setItem(key, value);\n        });\n      }\n    }\n    /**\r\n     * Delegates to tryLoginImplicitFlow for the sake of competability\r\n     * @param options Optional options.\r\n     */\n    tryLogin(options = null) {\n      if (this.config.responseType === 'code') {\n        return this.tryLoginCodeFlow(options).then(_ => true);\n      } else {\n        return this.tryLoginImplicitFlow(options);\n      }\n    }\n    parseQueryString(queryString) {\n      if (!queryString || queryString.length === 0) {\n        return {};\n      }\n      if (queryString.charAt(0) === '?') {\n        queryString = queryString.substr(1);\n      }\n      return this.urlHelper.parseQueryString(queryString);\n    }\n    tryLoginCodeFlow(options = null) {\n      options = options || {};\n      const querySource = options.customHashFragment ? options.customHashFragment.substring(1) : window.location.search;\n      const parts = this.getCodePartsFromUrl(querySource);\n      const code = parts['code'];\n      const state = parts['state'];\n      const sessionState = parts['session_state'];\n      if (!options.preventClearHashAfterLogin) {\n        const href = location.href.replace(/[&\\?]code=[^&\\$]*/, '').replace(/[&\\?]scope=[^&\\$]*/, '').replace(/[&\\?]state=[^&\\$]*/, '').replace(/[&\\?]session_state=[^&\\$]*/, '');\n        history.replaceState(null, window.name, href);\n      }\n      let [nonceInState, userState] = this.parseState(state);\n      this.state = userState;\n      if (parts['error']) {\n        this.debug('error trying to login');\n        this.handleLoginError({}, parts);\n        const err = new OAuthErrorEvent('code_error', {}, parts);\n        this.eventsSubject.next(err);\n        return Promise.reject(err);\n      }\n      if (!nonceInState) {\n        return Promise.resolve();\n      }\n      const success = this.validateNonce(nonceInState);\n      if (!success) {\n        const event = new OAuthErrorEvent('invalid_nonce_in_state', null);\n        this.eventsSubject.next(event);\n        return Promise.reject(event);\n      }\n      this.storeSessionState(sessionState);\n      if (code) {\n        return this.getTokenFromCode(code, options).then(_ => null);\n      } else {\n        return Promise.resolve();\n      }\n    }\n    /**\r\n     * Retrieve the returned auth code from the redirect uri that has been called.\r\n     * If required also check hash, as we could use hash location strategy.\r\n     */\n    getCodePartsFromUrl(queryString) {\n      if (!queryString || queryString.length === 0) {\n        return this.urlHelper.getHashFragmentParams();\n      }\n      // normalize query string\n      if (queryString.charAt(0) === '?') {\n        queryString = queryString.substr(1);\n      }\n      return this.urlHelper.parseQueryString(queryString);\n    }\n    /**\r\n     * Get token using an intermediate code. Works for the Authorization Code flow.\r\n     */\n    getTokenFromCode(code, options) {\n      let params = new HttpParams().set('grant_type', 'authorization_code').set('code', code).set('redirect_uri', options.customRedirectUri || this.redirectUri);\n      if (!this.disablePKCE) {\n        let pkciVerifier;\n        if (this.saveNoncesInLocalStorage && typeof window['localStorage'] !== 'undefined') {\n          pkciVerifier = localStorage.getItem('PKCI_verifier');\n        } else {\n          pkciVerifier = this._storage.getItem('PKCI_verifier');\n        }\n        if (!pkciVerifier) {\n          console.warn('No PKCI verifier found in oauth storage!');\n        } else {\n          params = params.set('code_verifier', pkciVerifier);\n        }\n      }\n      return this.fetchAndProcessToken(params);\n    }\n    fetchAndProcessToken(params) {\n      this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint, 'tokenEndpoint');\n      let headers = new HttpHeaders().set('Content-Type', 'application/x-www-form-urlencoded');\n      if (this.useHttpBasicAuth) {\n        const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n        headers = headers.set('Authorization', 'Basic ' + header);\n      }\n      if (!this.useHttpBasicAuth) {\n        params = params.set('client_id', this.clientId);\n      }\n      if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n        params = params.set('client_secret', this.dummyClientSecret);\n      }\n      return new Promise((resolve, reject) => {\n        if (this.customQueryParams) {\n          for (let key of Object.getOwnPropertyNames(this.customQueryParams)) {\n            params = params.set(key, this.customQueryParams[key]);\n          }\n        }\n        this.http.post(this.tokenEndpoint, params, {\n          headers\n        }).subscribe(tokenResponse => {\n          this.debug('refresh tokenResponse', tokenResponse);\n          this.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in || this.fallbackAccessTokenExpirationTimeInSec, tokenResponse.scope, this.extractRecognizedCustomParameters(tokenResponse));\n          if (this.oidc && tokenResponse.id_token) {\n            this.processIdToken(tokenResponse.id_token, tokenResponse.access_token).then(result => {\n              this.storeIdToken(result);\n              this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n              this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n              resolve(tokenResponse);\n            }).catch(reason => {\n              this.eventsSubject.next(new OAuthErrorEvent('token_validation_error', reason));\n              console.error('Error validating tokens');\n              console.error(reason);\n              reject(reason);\n            });\n          } else {\n            this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n            this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n            resolve(tokenResponse);\n          }\n        }, err => {\n          console.error('Error getting token', err);\n          this.eventsSubject.next(new OAuthErrorEvent('token_refresh_error', err));\n          reject(err);\n        });\n      });\n    }\n    /**\r\n     * Checks whether there are tokens in the hash fragment\r\n     * as a result of the implicit flow. These tokens are\r\n     * parsed, validated and used to sign the user in to the\r\n     * current client.\r\n     *\r\n     * @param options Optional options.\r\n     */\n    tryLoginImplicitFlow(options = null) {\n      options = options || {};\n      let parts;\n      if (options.customHashFragment) {\n        parts = this.urlHelper.getHashFragmentParams(options.customHashFragment);\n      } else {\n        parts = this.urlHelper.getHashFragmentParams();\n      }\n      this.debug('parsed url', parts);\n      const state = parts['state'];\n      let [nonceInState, userState] = this.parseState(state);\n      this.state = userState;\n      if (parts['error']) {\n        this.debug('error trying to login');\n        this.handleLoginError(options, parts);\n        const err = new OAuthErrorEvent('token_error', {}, parts);\n        this.eventsSubject.next(err);\n        return Promise.reject(err);\n      }\n      const accessToken = parts['access_token'];\n      const idToken = parts['id_token'];\n      const sessionState = parts['session_state'];\n      const grantedScopes = parts['scope'];\n      if (!this.requestAccessToken && !this.oidc) {\n        return Promise.reject('Either requestAccessToken or oidc (or both) must be true.');\n      }\n      if (this.requestAccessToken && !accessToken) {\n        return Promise.resolve(false);\n      }\n      if (this.requestAccessToken && !options.disableOAuth2StateCheck && !state) {\n        return Promise.resolve(false);\n      }\n      if (this.oidc && !idToken) {\n        return Promise.resolve(false);\n      }\n      if (this.sessionChecksEnabled && !sessionState) {\n        this.logger.warn('session checks (Session Status Change Notification) ' + 'were activated in the configuration but the id_token ' + 'does not contain a session_state claim');\n      }\n      if (this.requestAccessToken && !options.disableOAuth2StateCheck) {\n        const success = this.validateNonce(nonceInState);\n        if (!success) {\n          const event = new OAuthErrorEvent('invalid_nonce_in_state', null);\n          this.eventsSubject.next(event);\n          return Promise.reject(event);\n        }\n      }\n      if (this.requestAccessToken) {\n        this.storeAccessTokenResponse(accessToken, null, parts['expires_in'] || this.fallbackAccessTokenExpirationTimeInSec, grantedScopes);\n      }\n      if (!this.oidc) {\n        this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n        if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\n          location.hash = '';\n        }\n        this.callOnTokenReceivedIfExists(options);\n        return Promise.resolve(true);\n      }\n      return this.processIdToken(idToken, accessToken).then(result => {\n        if (options.validationHandler) {\n          return options.validationHandler({\n            accessToken: accessToken,\n            idClaims: result.idTokenClaims,\n            idToken: result.idToken,\n            state: state\n          }).then(_ => result);\n        }\n        return result;\n      }).then(result => {\n        this.storeIdToken(result);\n        this.storeSessionState(sessionState);\n        if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\n          location.hash = '';\n        }\n        this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n        this.callOnTokenReceivedIfExists(options);\n        this.inImplicitFlow = false;\n        return true;\n      }).catch(reason => {\n        this.eventsSubject.next(new OAuthErrorEvent('token_validation_error', reason));\n        this.logger.error('Error validating tokens');\n        this.logger.error(reason);\n        return Promise.reject(reason);\n      });\n    }\n    parseState(state) {\n      let nonce = state;\n      let userState = '';\n      if (state) {\n        const idx = state.indexOf(this.config.nonceStateSeparator);\n        if (idx > -1) {\n          nonce = state.substr(0, idx);\n          userState = state.substr(idx + this.config.nonceStateSeparator.length);\n        }\n      }\n      return [nonce, userState];\n    }\n    validateNonce(nonceInState) {\n      let savedNonce;\n      if (this.saveNoncesInLocalStorage && typeof window['localStorage'] !== 'undefined') {\n        savedNonce = localStorage.getItem('nonce');\n      } else {\n        savedNonce = this._storage.getItem('nonce');\n      }\n      if (savedNonce !== nonceInState) {\n        const err = 'Validating access_token failed, wrong state/nonce.';\n        console.error(err, savedNonce, nonceInState);\n        return false;\n      }\n      return true;\n    }\n    storeIdToken(idToken) {\n      this._storage.setItem('id_token', idToken.idToken);\n      this._storage.setItem('id_token_claims_obj', idToken.idTokenClaimsJson);\n      this._storage.setItem('id_token_expires_at', '' + idToken.idTokenExpiresAt);\n      this._storage.setItem('id_token_stored_at', '' + Date.now());\n    }\n    storeSessionState(sessionState) {\n      this._storage.setItem('session_state', sessionState);\n    }\n    getSessionState() {\n      return this._storage.getItem('session_state');\n    }\n    handleLoginError(options, parts) {\n      if (options.onLoginError) {\n        options.onLoginError(parts);\n      }\n      if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\n        location.hash = '';\n      }\n    }\n    /**\r\n     * @ignore\r\n     */\n    processIdToken(idToken, accessToken, skipNonceCheck = false) {\n      const tokenParts = idToken.split('.');\n      const headerBase64 = this.padBase64(tokenParts[0]);\n      const headerJson = b64DecodeUnicode(headerBase64);\n      const header = JSON.parse(headerJson);\n      const claimsBase64 = this.padBase64(tokenParts[1]);\n      const claimsJson = b64DecodeUnicode(claimsBase64);\n      const claims = JSON.parse(claimsJson);\n      let savedNonce;\n      if (this.saveNoncesInLocalStorage && typeof window['localStorage'] !== 'undefined') {\n        savedNonce = localStorage.getItem('nonce');\n      } else {\n        savedNonce = this._storage.getItem('nonce');\n      }\n      if (Array.isArray(claims.aud)) {\n        if (claims.aud.every(v => v !== this.clientId)) {\n          const err = 'Wrong audience: ' + claims.aud.join(',');\n          this.logger.warn(err);\n          return Promise.reject(err);\n        }\n      } else {\n        if (claims.aud !== this.clientId) {\n          const err = 'Wrong audience: ' + claims.aud;\n          this.logger.warn(err);\n          return Promise.reject(err);\n        }\n      }\n      if (!claims.sub) {\n        const err = 'No sub claim in id_token';\n        this.logger.warn(err);\n        return Promise.reject(err);\n      }\n      /* For now, we only check whether the sub against\r\n       * silentRefreshSubject when sessionChecksEnabled is on\r\n       * We will reconsider in a later version to do this\r\n       * in every other case too.\r\n       */\n      if (this.sessionChecksEnabled && this.silentRefreshSubject && this.silentRefreshSubject !== claims['sub']) {\n        const err = 'After refreshing, we got an id_token for another user (sub). ' + `Expected sub: ${this.silentRefreshSubject}, received sub: ${claims['sub']}`;\n        this.logger.warn(err);\n        return Promise.reject(err);\n      }\n      if (!claims.iat) {\n        const err = 'No iat claim in id_token';\n        this.logger.warn(err);\n        return Promise.reject(err);\n      }\n      if (!this.skipIssuerCheck && claims.iss !== this.issuer) {\n        const err = 'Wrong issuer: ' + claims.iss;\n        this.logger.warn(err);\n        return Promise.reject(err);\n      }\n      if (!skipNonceCheck && claims.nonce !== savedNonce) {\n        const err = 'Wrong nonce: ' + claims.nonce;\n        this.logger.warn(err);\n        return Promise.reject(err);\n      }\n      // at_hash is not applicable to authorization code flow\n      // addressing https://github.com/manfredsteyer/angular-oauth2-oidc/issues/661\n      // i.e. Based on spec the at_hash check is only true for implicit code flow on Ping Federate\n      // https://www.pingidentity.com/developer/en/resources/openid-connect-developers-guide.html\n      if (this.hasOwnProperty('responseType') && this.responseType === 'code') {\n        this.disableAtHashCheck = true;\n      }\n      if (!this.disableAtHashCheck && this.requestAccessToken && !claims['at_hash']) {\n        const err = 'An at_hash is needed!';\n        this.logger.warn(err);\n        return Promise.reject(err);\n      }\n      const now = Date.now();\n      const issuedAtMSec = claims.iat * 1000;\n      const expiresAtMSec = claims.exp * 1000;\n      const clockSkewInMSec = (this.clockSkewInSec || 600) * 1000;\n      if (issuedAtMSec - clockSkewInMSec >= now || expiresAtMSec + clockSkewInMSec <= now) {\n        const err = 'Token has expired';\n        console.error(err);\n        console.error({\n          now: now,\n          issuedAtMSec: issuedAtMSec,\n          expiresAtMSec: expiresAtMSec\n        });\n        return Promise.reject(err);\n      }\n      const validationParams = {\n        accessToken: accessToken,\n        idToken: idToken,\n        jwks: this.jwks,\n        idTokenClaims: claims,\n        idTokenHeader: header,\n        loadKeys: () => this.loadJwks()\n      };\n      if (this.disableAtHashCheck) {\n        return this.checkSignature(validationParams).then(_ => {\n          const result = {\n            idToken: idToken,\n            idTokenClaims: claims,\n            idTokenClaimsJson: claimsJson,\n            idTokenHeader: header,\n            idTokenHeaderJson: headerJson,\n            idTokenExpiresAt: expiresAtMSec\n          };\n          return result;\n        });\n      }\n      return this.checkAtHash(validationParams).then(atHashValid => {\n        if (!this.disableAtHashCheck && this.requestAccessToken && !atHashValid) {\n          const err = 'Wrong at_hash';\n          this.logger.warn(err);\n          return Promise.reject(err);\n        }\n        return this.checkSignature(validationParams).then(_ => {\n          const atHashCheckEnabled = !this.disableAtHashCheck;\n          const result = {\n            idToken: idToken,\n            idTokenClaims: claims,\n            idTokenClaimsJson: claimsJson,\n            idTokenHeader: header,\n            idTokenHeaderJson: headerJson,\n            idTokenExpiresAt: expiresAtMSec\n          };\n          if (atHashCheckEnabled) {\n            return this.checkAtHash(validationParams).then(atHashValid => {\n              if (this.requestAccessToken && !atHashValid) {\n                const err = 'Wrong at_hash';\n                this.logger.warn(err);\n                return Promise.reject(err);\n              } else {\n                return result;\n              }\n            });\n          } else {\n            return result;\n          }\n        });\n      });\n    }\n    /**\r\n     * Returns the received claims about the user.\r\n     */\n    getIdentityClaims() {\n      const claims = this._storage.getItem('id_token_claims_obj');\n      if (!claims) {\n        return null;\n      }\n      return JSON.parse(claims);\n    }\n    /**\r\n     * Returns the granted scopes from the server.\r\n     */\n    getGrantedScopes() {\n      const scopes = this._storage.getItem('granted_scopes');\n      if (!scopes) {\n        return null;\n      }\n      return JSON.parse(scopes);\n    }\n    /**\r\n     * Returns the current id_token.\r\n     */\n    getIdToken() {\n      return this._storage ? this._storage.getItem('id_token') : null;\n    }\n    padBase64(base64data) {\n      while (base64data.length % 4 !== 0) {\n        base64data += '=';\n      }\n      return base64data;\n    }\n    /**\r\n     * Returns the current access_token.\r\n     */\n    getAccessToken() {\n      return this._storage ? this._storage.getItem('access_token') : null;\n    }\n    getRefreshToken() {\n      return this._storage ? this._storage.getItem('refresh_token') : null;\n    }\n    /**\r\n     * Returns the expiration date of the access_token\r\n     * as milliseconds since 1970.\r\n     */\n    getAccessTokenExpiration() {\n      if (!this._storage.getItem('expires_at')) {\n        return null;\n      }\n      return parseInt(this._storage.getItem('expires_at'), 10);\n    }\n    getAccessTokenStoredAt() {\n      return parseInt(this._storage.getItem('access_token_stored_at'), 10);\n    }\n    getIdTokenStoredAt() {\n      return parseInt(this._storage.getItem('id_token_stored_at'), 10);\n    }\n    /**\r\n     * Returns the expiration date of the id_token\r\n     * as milliseconds since 1970.\r\n     */\n    getIdTokenExpiration() {\n      if (!this._storage.getItem('id_token_expires_at')) {\n        return null;\n      }\n      return parseInt(this._storage.getItem('id_token_expires_at'), 10);\n    }\n    /**\r\n     * Checkes, whether there is a valid access_token.\r\n     */\n    hasValidAccessToken() {\n      if (this.getAccessToken()) {\n        const expiresAt = this._storage.getItem('expires_at');\n        const now = new Date();\n        if (expiresAt && parseInt(expiresAt, 10) < now.getTime()) {\n          return false;\n        }\n        return true;\n      }\n      return false;\n    }\n    /**\r\n     * Checks whether there is a valid id_token.\r\n     */\n    hasValidIdToken() {\n      if (this.getIdToken()) {\n        const expiresAt = this._storage.getItem('id_token_expires_at');\n        const now = new Date();\n        if (expiresAt && parseInt(expiresAt, 10) < now.getTime()) {\n          return false;\n        }\n        return true;\n      }\n      return false;\n    }\n    /**\r\n     * Retrieve a saved custom property of the TokenReponse object. Only if predefined in authconfig.\r\n     */\n    getCustomTokenResponseProperty(requestedProperty) {\n      return this._storage && this.config.customTokenParameters && this.config.customTokenParameters.indexOf(requestedProperty) >= 0 && this._storage.getItem(requestedProperty) !== null ? JSON.parse(this._storage.getItem(requestedProperty)) : null;\n    }\n    /**\r\n     * Returns the auth-header that can be used\r\n     * to transmit the access_token to a service\r\n     */\n    authorizationHeader() {\n      return 'Bearer ' + this.getAccessToken();\n    }\n    /**\r\n     * Removes all tokens and logs the user out.\r\n     * If a logout url is configured, the user is\r\n     * redirected to it with optional state parameter.\r\n     * @param noRedirectToLogoutUrl\r\n     * @param state\r\n     */\n    logOut(noRedirectToLogoutUrl = false, state = '') {\n      const id_token = this.getIdToken();\n      this._storage.removeItem('access_token');\n      this._storage.removeItem('id_token');\n      this._storage.removeItem('refresh_token');\n      if (this.saveNoncesInLocalStorage) {\n        localStorage.removeItem('nonce');\n        localStorage.removeItem('PKCI_verifier');\n      } else {\n        this._storage.removeItem('nonce');\n        this._storage.removeItem('PKCI_verifier');\n      }\n      this._storage.removeItem('expires_at');\n      this._storage.removeItem('id_token_claims_obj');\n      this._storage.removeItem('id_token_expires_at');\n      this._storage.removeItem('id_token_stored_at');\n      this._storage.removeItem('access_token_stored_at');\n      this._storage.removeItem('granted_scopes');\n      this._storage.removeItem('session_state');\n      if (this.config.customTokenParameters) {\n        this.config.customTokenParameters.forEach(customParam => this._storage.removeItem(customParam));\n      }\n      this.silentRefreshSubject = null;\n      this.eventsSubject.next(new OAuthInfoEvent('logout'));\n      if (!this.logoutUrl) {\n        return;\n      }\n      if (noRedirectToLogoutUrl) {\n        return;\n      }\n      if (!id_token && !this.postLogoutRedirectUri) {\n        return;\n      }\n      let logoutUrl;\n      if (!this.validateUrlForHttps(this.logoutUrl)) {\n        throw new Error(\"logoutUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n      }\n      // For backward compatibility\n      if (this.logoutUrl.indexOf('{{') > -1) {\n        logoutUrl = this.logoutUrl.replace(/\\{\\{id_token\\}\\}/, id_token).replace(/\\{\\{client_id\\}\\}/, this.clientId);\n      } else {\n        let params = new HttpParams();\n        if (id_token) {\n          params = params.set('id_token_hint', id_token);\n        }\n        const postLogoutUrl = this.postLogoutRedirectUri || this.redirectUri;\n        if (postLogoutUrl) {\n          params = params.set('post_logout_redirect_uri', postLogoutUrl);\n          if (state) {\n            params = params.set('state', state);\n          }\n        }\n        logoutUrl = this.logoutUrl + (this.logoutUrl.indexOf('?') > -1 ? '&' : '?') + params.toString();\n      }\n      this.config.openUri(logoutUrl);\n    }\n    /**\r\n     * @ignore\r\n     */\n    createAndSaveNonce() {\n      const that = this;\n      return this.createNonce().then(function (nonce) {\n        // Use localStorage for nonce if possible\n        // localStorage is the only storage who survives a\n        // redirect in ALL browsers (also IE)\n        // Otherwiese we'd force teams who have to support\n        // IE into using localStorage for everything\n        if (that.saveNoncesInLocalStorage && typeof window['localStorage'] !== 'undefined') {\n          localStorage.setItem('nonce', nonce);\n        } else {\n          that._storage.setItem('nonce', nonce);\n        }\n        return nonce;\n      });\n    }\n    /**\r\n     * @ignore\r\n     */\n    ngOnDestroy() {\n      this.clearAccessTokenTimer();\n      this.clearIdTokenTimer();\n      this.removeSilentRefreshEventListener();\n      const silentRefreshFrame = this.document.getElementById(this.silentRefreshIFrameName);\n      if (silentRefreshFrame) {\n        silentRefreshFrame.remove();\n      }\n      this.stopSessionCheckTimer();\n      this.removeSessionCheckEventListener();\n      const sessionCheckFrame = this.document.getElementById(this.sessionCheckIFrameName);\n      if (sessionCheckFrame) {\n        sessionCheckFrame.remove();\n      }\n    }\n    createNonce() {\n      return new Promise(resolve => {\n        if (this.rngUrl) {\n          throw new Error('createNonce with rng-web-api has not been implemented so far');\n        }\n        /*\r\n         * This alphabet is from:\r\n         * https://tools.ietf.org/html/rfc7636#section-4.1\r\n         *\r\n         * [A-Z] / [a-z] / [0-9] / \"-\" / \".\" / \"_\" / \"~\"\r\n         */\n        const unreserved = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\n        let size = 45;\n        let id = '';\n        const crypto = typeof self === 'undefined' ? null : self.crypto || self['msCrypto'];\n        if (crypto) {\n          let bytes = new Uint8Array(size);\n          crypto.getRandomValues(bytes);\n          // Needed for IE\n          if (!bytes.map) {\n            bytes.map = Array.prototype.map;\n          }\n          bytes = bytes.map(x => unreserved.charCodeAt(x % unreserved.length));\n          id = String.fromCharCode.apply(null, bytes);\n        } else {\n          while (0 < size--) {\n            id += unreserved[Math.random() * unreserved.length | 0];\n          }\n        }\n        resolve(base64UrlEncode(id));\n      });\n    }\n    checkAtHash(params) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!this.tokenValidationHandler) {\n          this.logger.warn('No tokenValidationHandler configured. Cannot check at_hash.');\n          return true;\n        }\n        return this.tokenValidationHandler.validateAtHash(params);\n      });\n    }\n    checkSignature(params) {\n      if (!this.tokenValidationHandler) {\n        this.logger.warn('No tokenValidationHandler configured. Cannot check signature.');\n        return Promise.resolve(null);\n      }\n      return this.tokenValidationHandler.validateSignature(params);\n    }\n    /**\r\n     * Start the implicit flow or the code flow,\r\n     * depending on your configuration.\r\n     */\n    initLoginFlow(additionalState = '', params = {}) {\n      if (this.responseType === 'code') {\n        return this.initCodeFlow(additionalState, params);\n      } else {\n        return this.initImplicitFlow(additionalState, params);\n      }\n    }\n    /**\r\n     * Starts the authorization code flow and redirects to user to\r\n     * the auth servers login url.\r\n     */\n    initCodeFlow(additionalState = '', params = {}) {\n      if (this.loginUrl !== '') {\n        this.initCodeFlowInternal(additionalState, params);\n      } else {\n        this.events.pipe(filter(e => e.type === 'discovery_document_loaded')).subscribe(_ => this.initCodeFlowInternal(additionalState, params));\n      }\n    }\n    initCodeFlowInternal(additionalState = '', params = {}) {\n      if (!this.validateUrlForHttps(this.loginUrl)) {\n        throw new Error(\"loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n      }\n      this.createLoginUrl(additionalState, '', null, false, params).then(this.config.openUri).catch(error => {\n        console.error('Error in initAuthorizationCodeFlow');\n        console.error(error);\n      });\n    }\n    createChallangeVerifierPairForPKCE() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!this.crypto) {\n          throw new Error('PKCE support for code flow needs a CryptoHander. Did you import the OAuthModule using forRoot() ?');\n        }\n        const verifier = yield this.createNonce();\n        const challengeRaw = yield this.crypto.calcHash(verifier, 'sha-256');\n        const challenge = base64UrlEncode(challengeRaw);\n        return [challenge, verifier];\n      });\n    }\n    extractRecognizedCustomParameters(tokenResponse) {\n      let foundParameters = new Map();\n      if (!this.config.customTokenParameters) {\n        return foundParameters;\n      }\n      this.config.customTokenParameters.forEach(recognizedParameter => {\n        if (tokenResponse[recognizedParameter]) {\n          foundParameters.set(recognizedParameter, JSON.stringify(tokenResponse[recognizedParameter]));\n        }\n      });\n      return foundParameters;\n    }\n    /**\r\n     * Revokes the auth token to secure the vulnarability\r\n     * of the token issued allowing the authorization server to clean\r\n     * up any security credentials associated with the authorization\r\n     */\n    revokeTokenAndLogout() {\n      let revokeEndpoint = this.revocationEndpoint;\n      let accessToken = this.getAccessToken();\n      let refreshToken = this.getRefreshToken();\n      if (!accessToken) {\n        return;\n      }\n      let params = new HttpParams();\n      let headers = new HttpHeaders().set('Content-Type', 'application/x-www-form-urlencoded');\n      if (this.useHttpBasicAuth) {\n        const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n        headers = headers.set('Authorization', 'Basic ' + header);\n      }\n      if (!this.useHttpBasicAuth) {\n        params = params.set('client_id', this.clientId);\n      }\n      if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n        params = params.set('client_secret', this.dummyClientSecret);\n      }\n      if (this.customQueryParams) {\n        for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n          params = params.set(key, this.customQueryParams[key]);\n        }\n      }\n      return new Promise((resolve, reject) => {\n        let revokeAccessToken;\n        let revokeRefreshToken;\n        if (accessToken) {\n          let revokationParams = params.set('token', accessToken).set('token_type_hint', 'access_token');\n          revokeAccessToken = this.http.post(revokeEndpoint, revokationParams, {\n            headers\n          });\n        } else {\n          revokeAccessToken = of(null);\n        }\n        if (refreshToken) {\n          let revokationParams = params.set('token', refreshToken).set('token_type_hint', 'refresh_token');\n          revokeRefreshToken = this.http.post(revokeEndpoint, revokationParams, {\n            headers\n          });\n        } else {\n          revokeRefreshToken = of(null);\n        }\n        combineLatest([revokeAccessToken, revokeRefreshToken]).subscribe(res => {\n          this.logOut();\n          resolve(res);\n          this.logger.info('Token successfully revoked');\n        }, err => {\n          this.logger.error('Error revoking token', err);\n          this.eventsSubject.next(new OAuthErrorEvent('token_revoke_error', err));\n          reject(err);\n        });\n      });\n    }\n  };\n  OAuthService = __decorate([Injectable(), __param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __param(7, Optional()), __param(8, Inject(DOCUMENT)), __metadata(\"design:paramtypes\", [NgZone, HttpClient, OAuthStorage, ValidationHandler, AuthConfig, UrlHelperService, OAuthLogger, HashHandler, Document])], OAuthService);\n  return OAuthService;\n})();\nclass OAuthModuleConfig {}\nclass OAuthResourceServerConfig {}\nclass OAuthResourceServerErrorHandler {}\nclass OAuthNoopResourceServerErrorHandler {\n  handleError(err) {\n    return throwError(err);\n  }\n}\nlet DefaultOAuthInterceptor = /*#__PURE__*/(() => {\n  let DefaultOAuthInterceptor = class DefaultOAuthInterceptor {\n    constructor(authStorage, oAuthService, errorHandler, moduleConfig) {\n      this.authStorage = authStorage;\n      this.oAuthService = oAuthService;\n      this.errorHandler = errorHandler;\n      this.moduleConfig = moduleConfig;\n    }\n    checkUrl(url) {\n      if (this.moduleConfig.resourceServer.customUrlValidation) {\n        return this.moduleConfig.resourceServer.customUrlValidation(url);\n      }\n      if (this.moduleConfig.resourceServer.allowedUrls) {\n        return !!this.moduleConfig.resourceServer.allowedUrls.find(u => url.startsWith(u));\n      }\n      return true;\n    }\n    intercept(req, next) {\n      const url = req.url.toLowerCase();\n      if (!this.moduleConfig || !this.moduleConfig.resourceServer || !this.checkUrl(url)) {\n        return next.handle(req);\n      }\n      const sendAccessToken = this.moduleConfig.resourceServer.sendAccessToken;\n      if (!sendAccessToken) {\n        return next.handle(req).pipe(catchError(err => this.errorHandler.handleError(err)));\n      }\n      return merge(of(this.oAuthService.getAccessToken()).pipe(filter(token => token ? true : false)), this.oAuthService.events.pipe(filter(e => e.type === 'token_received'), timeout(this.oAuthService.waitForTokenInMsec || 0), catchError(_ => of(null)),\n      // timeout is not an error\n      map(_ => this.oAuthService.getAccessToken()))).pipe(take(1), mergeMap(token => {\n        if (token) {\n          const header = 'Bearer ' + token;\n          const headers = req.headers.set('Authorization', header);\n          req = req.clone({\n            headers\n          });\n        }\n        return next.handle(req).pipe(catchError(err => this.errorHandler.handleError(err)));\n      }));\n    }\n  };\n  DefaultOAuthInterceptor = __decorate([Injectable(), __param(3, Optional()), __metadata(\"design:paramtypes\", [OAuthStorage, OAuthService, OAuthResourceServerErrorHandler, OAuthModuleConfig])], DefaultOAuthInterceptor);\n\n  /**\r\n   * A validation handler that isn't validating nothing.\r\n   * Can be used to skip validation (at your own risk).\r\n   */\n  return DefaultOAuthInterceptor;\n})();\nclass NullValidationHandler {\n  validateSignature(validationParams) {\n    return Promise.resolve(null);\n  }\n  validateAtHash(validationParams) {\n    return Promise.resolve(true);\n  }\n}\nfunction createDefaultLogger() {\n  return console;\n}\nfunction createDefaultStorage() {\n  return typeof sessionStorage !== 'undefined' ? sessionStorage : new MemoryStorage();\n}\nvar OAuthModule_1;\nlet OAuthModule = OAuthModule_1 = class OAuthModule {\n  static forRoot(config = null, validationHandlerClass = NullValidationHandler) {\n    return {\n      ngModule: OAuthModule_1,\n      providers: [OAuthService, UrlHelperService, {\n        provide: OAuthLogger,\n        useFactory: createDefaultLogger\n      }, {\n        provide: OAuthStorage,\n        useFactory: createDefaultStorage\n      }, {\n        provide: ValidationHandler,\n        useClass: validationHandlerClass\n      }, {\n        provide: HashHandler,\n        useClass: DefaultHashHandler\n      }, {\n        provide: OAuthResourceServerErrorHandler,\n        useClass: OAuthNoopResourceServerErrorHandler\n      }, {\n        provide: OAuthModuleConfig,\n        useValue: config\n      }, {\n        provide: HTTP_INTERCEPTORS,\n        useClass: DefaultOAuthInterceptor,\n        multi: true\n      }]\n    };\n  }\n};\nOAuthModule = OAuthModule_1 = __decorate([NgModule({\n  imports: [CommonModule],\n  declarations: [],\n  exports: []\n})], OAuthModule);\nconst err = `PLEASE READ THIS CAREFULLY:\n\nBeginning with angular-oauth2-oidc version 9, the JwksValidationHandler\nhas been moved to an library of its own. If you need it for implementing\nOAuth2/OIDC **implicit flow**, please install it using npm:\n\n  npm i angular-oauth2-oidc-jwks --save\n\nAfter that, you can import it into your application:\n\n  import { JwksValidationHandler } from 'angular-oauth2-oidc-jwks';\n\nPlease note, that this dependency is not needed for the **code flow**,\nwhich is nowadays the **recommented** one for single page applications.\nThis also results in smaller bundle sizes.\n`;\n/**\r\n * This is just a dummy of the JwksValidationHandler\r\n * telling the users that the real one has been moved\r\n * to an library of its own, namely angular-oauth2-oidc-utils\r\n */\nclass JwksValidationHandler extends NullValidationHandler {\n  constructor() {\n    super();\n    console.error(err);\n  }\n}\nconst AUTH_CONFIG = new InjectionToken('AUTH_CONFIG');\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { AUTH_CONFIG, AbstractValidationHandler, AuthConfig, DefaultOAuthInterceptor, JwksValidationHandler, LoginOptions, MemoryStorage, NullValidationHandler, OAuthErrorEvent, OAuthEvent, OAuthInfoEvent, OAuthLogger, OAuthModule, OAuthModuleConfig, OAuthNoopResourceServerErrorHandler, OAuthResourceServerConfig, OAuthResourceServerErrorHandler, OAuthService, OAuthStorage, OAuthSuccessEvent, ReceivedTokens, UrlHelperService, ValidationHandler, HashHandler as a, DefaultHashHandler as b, createDefaultLogger as c, createDefaultStorage as d };\n//# sourceMappingURL=angular-oauth2-oidc.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}