{"ast":null,"code":"import { USEHTTPSERVICE, ABOVE_LEVEL_OFFSET, BELOW_LEVEL_OFFSET } from '../base/globalconstants';\nimport { ApplicationModeT } from '../base/applicationmode';\nimport { MapLayerBase } from './mapLayerBase';\nimport { OpenlayersHelper } from './openlayershelper';\nimport { MapNodesStyles } from './mapNodesStyles';\nimport ol_layer_Vector from 'ol/layer/Vector';\nimport ol_source_Vector from 'ol/source/Vector';\nimport ol_format_GeoJSON from 'ol/format/GeoJSON';\nimport ol_interaction_Select from 'ol/interaction/Select';\nimport ol_interaction_Modify from 'ol/interaction/Modify';\nimport { never as eventnevercondition } from 'ol/events/condition';\nexport class MapNodes extends MapLayerBase {\n  constructor(mapService, mapEditEdges, mapEdges, mapRoute) {\n    super();\n    this.mapService = mapService;\n    this.mapEditEdges = mapEditEdges;\n    this.mapEdges = mapEdges;\n    this.mapRoute = mapRoute;\n    this.highlightFeatureOverlay = null;\n    this.displayEditLines = false;\n    this.isModifying = false;\n    this.lastMousePostion = [0, 0];\n    this.currentLevel = undefined;\n    this.ctrlPressed = false;\n    this.lastSelectedNode = null;\n    this.multiLevelMode = false;\n    this.Initialize();\n  }\n  Initialize() {\n    let styleFunction = function (feature) {\n      if (feature.get('ctype') == 'node') {\n        return MapNodesStyles.VirtualNodeStyle;\n      }\n      if (feature.get('ctype') == 'point of interest instance') {\n        return MapNodesStyles.PoiNodeStyle;\n      }\n      return MapNodesStyles.DefaultNodeStyle;\n    };\n    let res = OpenlayersHelper.CreateBasicLayer(styleFunction);\n    this.layerSource = res.layerSource;\n    this.layer = res.layer;\n  }\n  extendMap(map) {\n    this.select = new ol_interaction_Select({\n      wrapX: false,\n      layers: layer => this.testSelect(layer),\n      toggleCondition: eventnevercondition\n    });\n    map.addInteraction(this.select);\n    this.modify = new ol_interaction_Modify({\n      features: this.select.getFeatures(),\n      condition: evt => this.testModify(evt)\n    });\n    map.addInteraction(this.modify);\n    this.select.on('select', evt => this.featureSelected(evt));\n    this.modify.on('modifystart', evt => this.featureModifyStart(evt));\n    this.modify.on('modifyend', evt => this.featureModified(evt));\n  }\n  updateData(floor, multiLevel) {\n    this.multiLevelMode = multiLevel;\n    this.currentLevel = floor;\n    this.clear();\n    this.subscribeNewRequest(this.mapService.getNavigationNodes(this.currentLevel.id).subscribe(nodes => this.showNodes(nodes)));\n  }\n  mouseMoved(position, worldposition, map) {\n    this.lastMousePostion = worldposition;\n    if (this.highlightFeatureOverlay === null) {\n      this.initHighlightFeatureOverlay(map);\n    }\n    let options = {\n      layerFilter: layer => this.testLayer(layer)\n    };\n    let feature = map.forEachFeatureAtPixel(position, function (feature) {\n      return feature;\n    }, options);\n    if (feature !== this.highlightedFeature) {\n      if (this.highlightedFeature) {\n        this.highlightFeatureOverlay.getSource().removeFeature(this.highlightedFeature);\n      }\n      if (feature) {\n        //console.log('Highlight feature: ' + JSON.stringify(feature.getKeys()));\n        //console.log('Highlight feature: ' + JSON.stringify(feature.get('id')));\n        this.highlightFeatureOverlay.getSource().addFeature(feature);\n      }\n      this.highlightedFeature = feature;\n    }\n    this.mapEdges.updateMouseMoved(position, map, this.highlightedFeature == null);\n    if (this.displayEditLines || this.isModifying) {\n      this.mapEditEdges.setNewEndPos(worldposition);\n    }\n  }\n  mouseClicked(position, map) {\n    if (this.displayEditLines) {\n      let selectedFeature = null;\n      let selectedFeatures = this.select.getFeatures().getArray();\n      if (selectedFeatures.length >= 1) {\n        selectedFeature = selectedFeatures[0];\n      }\n      if (this.highlightedFeature) {\n        //Add edge to existing Node\n        this.selectNewNode(this.highlightedFeature);\n        this.addNewEdge(selectedFeature, this.highlightedFeature);\n      } else {\n        this.addNewNodeOnPos(selectedFeature, position);\n      }\n    } else if (this.lastSelectedNode && this.highlightedFeature && this.ctrlPressed) {\n      this.selectNewNode(this.highlightedFeature);\n      this.addNewEdge(this.lastSelectedNode, this.highlightedFeature);\n    } else if (!this.highlightedFeature) {\n      this.mapEdges.updateMouseClicked(map);\n    } else {\n      this.mapEdges.clearSelection();\n    }\n  }\n  ctlPressed() {\n    this.ctrlPressed = true;\n    let selectedFeatures = this.select.getFeatures().getArray();\n    if (selectedFeatures.length >= 1) {\n      this.displayEditLines = true;\n      let coord = selectedFeatures[0].getGeometry().getCoordinates();\n      console.log(\"Set Startpoint: \" + JSON.stringify(coord));\n      this.mapEditEdges.setNewStartPos(coord);\n      this.mapEditEdges.setNewEndPos(this.lastMousePostion);\n    }\n  }\n  ctlReleased() {\n    this.ctrlPressed = false;\n    console.log(\"ctlReleased...\");\n    this.displayEditLines = false;\n    this.mapEditEdges.clear();\n  }\n  updateAddNode(node, selectedStartNodeFeature, edgeToSplitId) {\n    console.log(\"updateAddNode! - \" + JSON.stringify(node));\n    this.layerSource.addFeatures(new ol_format_GeoJSON().readFeatures(node));\n    let endNode = this.layerSource.getFeatureById(node.id);\n    this.selectNewNode(endNode);\n    if (selectedStartNodeFeature) {\n      this.addNewEdge(selectedStartNodeFeature, endNode);\n      console.log(\"Split Edge?\");\n      if (edgeToSplitId >= 0) {\n        let edgeToSplit = this.mapEdges.getEdgeForId(edgeToSplitId);\n        if (edgeToSplit) {\n          console.log(\"Split Edge: \" + edgeToSplit.getId());\n          let node1 = this.layerSource.getFeatureById(edgeToSplit.get(\"source\"));\n          let node2 = this.layerSource.getFeatureById(edgeToSplit.get(\"destination\"));\n          this.mapEdges.deleteEdgeById(edgeToSplit.getId());\n          if (node1) {\n            this.addNewEdge(node1, endNode);\n          }\n          if (node2) {\n            this.addNewEdge(node2, endNode);\n          }\n        }\n      }\n    }\n  }\n  selectNewNode(node) {\n    let selectedFeatures = this.select.getFeatures();\n    selectedFeatures.clear();\n    selectedFeatures.push(node);\n    let coord = node.getGeometry().getCoordinates();\n    this.mapEditEdges.setNewStartPos(coord);\n    this.mapEditEdges.setNewEndPos(coord);\n  }\n  addNewEdge(start, end) {\n    //console.log(\"addNewEdge! - \" + JSON.stringify(start.getId()) + \" to \" + end.getId());\n    this.mapEdges.addNewEdge(start, end);\n  }\n  deleteSelectedNodes() {\n    if (!USEHTTPSERVICE) {\n      console.log(\"Offline mode, dont delete edge!\");\n      return;\n    }\n    for (let feature of this.select.getFeatures().getArray()) {\n      if (feature.get('ctype') == 'node') {\n        this.mapService.deleteNode(feature.getId()).subscribe(edge => this.nodeDeleted(edge), error => console.log(\"ERROR deleteNode: \" + error));\n      } else {\n        console.log(\"Not allowed to delete feature of type: \" + feature.get('ctype'));\n      }\n    }\n  }\n  nodeDeleted(node) {\n    console.log(\"edgeDeleted...\" + JSON.stringify(node));\n    this.mapEdges.removeEdgesForNode(node.id);\n    let feature = this.layerSource.getFeatureById(node.id);\n    if (feature) {\n      this.layerSource.removeFeature(feature);\n      let selected_collection = this.select.getFeatures();\n      selected_collection.clear();\n    }\n  }\n  testLayer(layer) {\n    return this.layer === layer;\n  }\n  testSelect(layer) {\n    if (this.testLayer(layer) && (OpenlayersHelper.CurrentApplicationMode.mode == ApplicationModeT.EDIT_NODES || OpenlayersHelper.CurrentApplicationMode.mode == ApplicationModeT.EDIT_MULTIFLOOR_EDGES)) {\n      return true;\n    }\n    return false;\n  }\n  testModify(evt) {\n    if (OpenlayersHelper.CurrentApplicationMode.mode == ApplicationModeT.EDIT_NODES) {\n      let selectedFeatures = this.select.getFeatures().getArray();\n      if (selectedFeatures.length > 0 && selectedFeatures[0].get('ctype') == 'node') {\n        return true;\n      }\n      return false;\n    }\n    return false;\n  }\n  addNewNodeOnPos(selectedFeature, position) {\n    if (!this.currentLevel || this.currentLevel.id < 0) {\n      return;\n    }\n    //console.log(\"mouseClickedCtrl! - POS: \" + JSON.stringify(position));\n    let center = {\n      \"type\": \"Point\",\n      \"coordinates\": [position[0], position[1]]\n    };\n    //console.log(\"mouseClickedCtrl! - OBJ: \" + JSON.stringify(center));\n    let highlightedEdgeId = this.mapEdges.getHighlightedEdgeId();\n    console.log(\"mouseClicked Add new node: \" + JSON.stringify(center) + \"   SplitEdgeID: \" + highlightedEdgeId);\n    //Add edge to new Node\n    this.mapService.addNode(this.currentLevel.id, center).subscribe(node => this.updateAddNode(node, selectedFeature, highlightedEdgeId), error => console.log(\"ERROR: \" + error));\n  }\n  initHighlightFeatureOverlay(map) {\n    this.highlightFeatureOverlay = new ol_layer_Vector({\n      source: new ol_source_Vector(),\n      map: map,\n      style: MapNodesStyles.higlightStyle\n    });\n  }\n  showNodes(features) {\n    this.clear();\n    this.layerSource.addFeatures(new ol_format_GeoJSON().readFeatures(features));\n    if (this.multiLevelMode) {\n      this.subscribeNewRequest(this.mapService.getNavigationNodes(this.currentLevel.floorAbove).subscribe(nodes => this.showNodesAbove(nodes), error => console.log(\"ERROR show Node: \" + error)));\n    }\n  }\n  showNodesAbove(features) {\n    let ol_features = new ol_format_GeoJSON().readFeatures(features);\n    for (let i = 0; i < ol_features.length; i++) {\n      ol_features[i].getGeometry().translate(ABOVE_LEVEL_OFFSET, 0);\n    }\n    this.layerSource.addFeatures(ol_features);\n    this.subscribeNewRequest(this.mapService.getNavigationNodes(this.currentLevel.floorBelow).subscribe(rooms => this.showNodesBelow(rooms), error => console.log(\"ERROR show Node: \" + error)));\n  }\n  showNodesBelow(features) {\n    let ol_features = new ol_format_GeoJSON().readFeatures(features);\n    for (let i = 0; i < ol_features.length; i++) {\n      //let coord = ol_features[i].getGeometry().getCoordinates();\n      //ol.coordinate.add(coord, 10, 0);\n      ol_features[i].getGeometry().translate(BELOW_LEVEL_OFFSET, 0);\n    }\n    this.layerSource.addFeatures(ol_features);\n  }\n  featureSelected(evt) {\n    let features = evt.selected;\n    if (features.length > 0) {\n      console.log(\"Feature selected => \" + features[0].getId());\n      this.lastSelectedNode = features[0];\n      if (this.mapRoute.doShowRoute()) {\n        this.mapRoute.generateRoute(features[0].getId());\n      }\n      this.mapRoute.setNewStartPos(features[0].getId());\n    }\n  }\n  featureModified(evt) {\n    console.log(\"MapNodes::featureModifyEnd...\");\n    this.isModifying = false;\n    this.mapEditEdges.clear();\n    let features = evt.features.getArray();\n    for (let feature of features) {\n      console.log(\"Feature \" + feature.getId() + \" modified!\");\n      this.mapService.updateNode(new ol_format_GeoJSON().writeFeature(feature), feature.getId()).subscribe(node => this.nodeUpdated(node), error => console.log(\"ERROR: \" + error));\n      let edges = this.mapEdges.getEdgesForNode(feature.getId());\n      this.mapEditEdges.updateEdges(edges, feature);\n    }\n  }\n  featureModifyStart(evt) {\n    console.log(\"MapNodes::featureModifyStart...\");\n    let selFeatures = this.select.getFeatures().getArray();\n    console.log(\"Feature selected: \" + selFeatures.length);\n    if (selFeatures.length >= 1) {\n      let edges = this.mapEdges.getEdgesForNode(selFeatures[0].getId());\n      console.log(\"Feature selected: \" + selFeatures[0].getId() + \"  Edges: \" + edges.length);\n      this.mapEditEdges.setNewStartPositionsForEdgeFeatures(selFeatures[0].getId(), edges);\n    }\n    this.isModifying = true;\n  }\n  nodeUpdated(node) {\n    console.log(\"node Updated! - \" + JSON.stringify(node));\n  }\n  clearSelection() {\n    let selectedFeatures = this.select.getFeatures();\n    selectedFeatures.clear();\n    this.displayEditLines = false;\n    this.isModifying = false;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}